// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings to opus
class LibOpus {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LibOpus(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LibOpus.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Converts an opus error code into a human readable string.
  ///
  /// @param[in] error <tt>int</tt>: Error number
  /// @returns Error string
  ffi.Pointer<ffi.Int8> opus_strerror(
    int error,
  ) {
    return _opus_strerror(
      error,
    );
  }

  late final _opus_strerror_ptr =
      _lookup<ffi.NativeFunction<_c_opus_strerror>>('opus_strerror');
  late final _dart_opus_strerror _opus_strerror =
      _opus_strerror_ptr.asFunction<_dart_opus_strerror>();

  /// Gets the libopus version string.
  ///
  /// Applications may look for the substring "-fixed" in the version string to
  /// determine whether they have a fixed-point or floating-point build at
  /// runtime.
  ///
  /// @returns Version string
  ffi.Pointer<ffi.Int8> opus_get_version_string() {
    return _opus_get_version_string();
  }

  late final _opus_get_version_string_ptr =
      _lookup<ffi.NativeFunction<_c_opus_get_version_string>>(
          'opus_get_version_string');
  late final _dart_opus_get_version_string _opus_get_version_string =
      _opus_get_version_string_ptr.asFunction<_dart_opus_get_version_string>();

  /// Creates a new mode struct. This will be passed to an encoder or
  /// decoder. The mode MUST NOT BE DESTROYED until the encoders and
  /// decoders that use it are destroyed as well.
  /// @param [in] Fs <tt>int</tt>: Sampling rate (8000 to 96000 Hz)
  /// @param [in] frame_size <tt>int</tt>: Number of samples (per channel) to encode in each
  /// packet (64 - 1024, prime factorization must contain zero or more 2s, 3s, or 5s and no other primes)
  /// @param [out] error <tt>int*</tt>: Returned error code (if NULL, no error will be returned)
  /// @return A newly created mode
  ffi.Pointer<OpusCustomMode> opus_custom_mode_create(
    int Fs,
    int frame_size,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _opus_custom_mode_create(
      Fs,
      frame_size,
      error,
    );
  }

  late final _opus_custom_mode_create_ptr =
      _lookup<ffi.NativeFunction<_c_opus_custom_mode_create>>(
          'opus_custom_mode_create');
  late final _dart_opus_custom_mode_create _opus_custom_mode_create =
      _opus_custom_mode_create_ptr.asFunction<_dart_opus_custom_mode_create>();

  /// Destroys a mode struct. Only call this after all encoders and
  /// decoders using this mode are destroyed as well.
  /// @param [in] mode <tt>OpusCustomMode*</tt>: Mode to be freed.
  void opus_custom_mode_destroy(
    ffi.Pointer<OpusCustomMode> mode,
  ) {
    return _opus_custom_mode_destroy(
      mode,
    );
  }

  late final _opus_custom_mode_destroy_ptr =
      _lookup<ffi.NativeFunction<_c_opus_custom_mode_destroy>>(
          'opus_custom_mode_destroy');
  late final _dart_opus_custom_mode_destroy _opus_custom_mode_destroy =
      _opus_custom_mode_destroy_ptr
          .asFunction<_dart_opus_custom_mode_destroy>();

  /// Gets the size of an OpusCustomEncoder structure.
  /// @param [in] mode <tt>OpusCustomMode *</tt>: Mode configuration
  /// @param [in] channels <tt>int</tt>: Number of channels
  /// @returns size
  int opus_custom_encoder_get_size(
    ffi.Pointer<OpusCustomMode> mode,
    int channels,
  ) {
    return _opus_custom_encoder_get_size(
      mode,
      channels,
    );
  }

  late final _opus_custom_encoder_get_size_ptr =
      _lookup<ffi.NativeFunction<_c_opus_custom_encoder_get_size>>(
          'opus_custom_encoder_get_size');
  late final _dart_opus_custom_encoder_get_size _opus_custom_encoder_get_size =
      _opus_custom_encoder_get_size_ptr
          .asFunction<_dart_opus_custom_encoder_get_size>();

  /// Creates a new encoder state. Each stream needs its own encoder
  /// state (can't be shared across simultaneous streams).
  /// @param [in] mode <tt>OpusCustomMode*</tt>: Contains all the information about the characteristics of
  /// the stream (must be the same characteristics as used for the
  /// decoder)
  /// @param [in] channels <tt>int</tt>: Number of channels
  /// @param [out] error <tt>int*</tt>: Returns an error code
  /// @return Newly created encoder state.
  ffi.Pointer<OpusCustomEncoder> opus_custom_encoder_create(
    ffi.Pointer<OpusCustomMode> mode,
    int channels,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _opus_custom_encoder_create(
      mode,
      channels,
      error,
    );
  }

  late final _opus_custom_encoder_create_ptr =
      _lookup<ffi.NativeFunction<_c_opus_custom_encoder_create>>(
          'opus_custom_encoder_create');
  late final _dart_opus_custom_encoder_create _opus_custom_encoder_create =
      _opus_custom_encoder_create_ptr
          .asFunction<_dart_opus_custom_encoder_create>();

  /// Destroys a an encoder state.
  /// @param[in] st <tt>OpusCustomEncoder*</tt>: State to be freed.
  void opus_custom_encoder_destroy(
    ffi.Pointer<OpusCustomEncoder> st,
  ) {
    return _opus_custom_encoder_destroy(
      st,
    );
  }

  late final _opus_custom_encoder_destroy_ptr =
      _lookup<ffi.NativeFunction<_c_opus_custom_encoder_destroy>>(
          'opus_custom_encoder_destroy');
  late final _dart_opus_custom_encoder_destroy _opus_custom_encoder_destroy =
      _opus_custom_encoder_destroy_ptr
          .asFunction<_dart_opus_custom_encoder_destroy>();

  /// Encodes a frame of audio.
  /// @param [in] st <tt>OpusCustomEncoder*</tt>: Encoder state
  /// @param [in] pcm <tt>float*</tt>: PCM audio in float format, with a normal range of +/-1.0.
  /// Samples with a range beyond +/-1.0 are supported but will
  /// be clipped by decoders using the integer API and should
  /// only be used if it is known that the far end supports
  /// extended dynamic range. There must be exactly
  /// frame_size samples per channel.
  /// @param [in] frame_size <tt>int</tt>: Number of samples per frame of input signal
  /// @param [out] compressed <tt>char *</tt>: The compressed data is written here. This may not alias pcm and must be at least maxCompressedBytes long.
  /// @param [in] maxCompressedBytes <tt>int</tt>: Maximum number of bytes to use for compressing the frame
  /// (can change from one frame to another)
  /// @return Number of bytes written to "compressed".
  /// If negative, an error has occurred (see error codes). It is IMPORTANT that
  /// the length returned be somehow transmitted to the decoder. Otherwise, no
  /// decoding is possible.
  int opus_custom_encode_float(
    ffi.Pointer<OpusCustomEncoder> st,
    ffi.Pointer<ffi.Float> pcm,
    int frame_size,
    ffi.Pointer<ffi.Uint8> compressed,
    int maxCompressedBytes,
  ) {
    return _opus_custom_encode_float(
      st,
      pcm,
      frame_size,
      compressed,
      maxCompressedBytes,
    );
  }

  late final _opus_custom_encode_float_ptr =
      _lookup<ffi.NativeFunction<_c_opus_custom_encode_float>>(
          'opus_custom_encode_float');
  late final _dart_opus_custom_encode_float _opus_custom_encode_float =
      _opus_custom_encode_float_ptr
          .asFunction<_dart_opus_custom_encode_float>();

  /// Encodes a frame of audio.
  /// @param [in] st <tt>OpusCustomEncoder*</tt>: Encoder state
  /// @param [in] pcm <tt>opus_int16*</tt>: PCM audio in signed 16-bit format (native endian).
  /// There must be exactly frame_size samples per channel.
  /// @param [in] frame_size <tt>int</tt>: Number of samples per frame of input signal
  /// @param [out] compressed <tt>char *</tt>: The compressed data is written here. This may not alias pcm and must be at least maxCompressedBytes long.
  /// @param [in] maxCompressedBytes <tt>int</tt>: Maximum number of bytes to use for compressing the frame
  /// (can change from one frame to another)
  /// @return Number of bytes written to "compressed".
  /// If negative, an error has occurred (see error codes). It is IMPORTANT that
  /// the length returned be somehow transmitted to the decoder. Otherwise, no
  /// decoding is possible.
  int opus_custom_encode(
    ffi.Pointer<OpusCustomEncoder> st,
    ffi.Pointer<ffi.Int16> pcm,
    int frame_size,
    ffi.Pointer<ffi.Uint8> compressed,
    int maxCompressedBytes,
  ) {
    return _opus_custom_encode(
      st,
      pcm,
      frame_size,
      compressed,
      maxCompressedBytes,
    );
  }

  late final _opus_custom_encode_ptr =
      _lookup<ffi.NativeFunction<_c_opus_custom_encode>>('opus_custom_encode');
  late final _dart_opus_custom_encode _opus_custom_encode =
      _opus_custom_encode_ptr.asFunction<_dart_opus_custom_encode>();

  /// Perform a CTL function on an Opus custom encoder.
  ///
  /// Generally the request and subsequent arguments are generated
  /// by a convenience macro.
  /// @see opus_encoderctls
  int opus_custom_encoder_ctl(
    ffi.Pointer<OpusCustomEncoder> st,
    int request,
  ) {
    return _opus_custom_encoder_ctl(
      st,
      request,
    );
  }

  late final _opus_custom_encoder_ctl_ptr =
      _lookup<ffi.NativeFunction<_c_opus_custom_encoder_ctl>>(
          'opus_custom_encoder_ctl');
  late final _dart_opus_custom_encoder_ctl _opus_custom_encoder_ctl =
      _opus_custom_encoder_ctl_ptr.asFunction<_dart_opus_custom_encoder_ctl>();

  /// Gets the size of an OpusCustomDecoder structure.
  /// @param [in] mode <tt>OpusCustomMode *</tt>: Mode configuration
  /// @param [in] channels <tt>int</tt>: Number of channels
  /// @returns size
  int opus_custom_decoder_get_size(
    ffi.Pointer<OpusCustomMode> mode,
    int channels,
  ) {
    return _opus_custom_decoder_get_size(
      mode,
      channels,
    );
  }

  late final _opus_custom_decoder_get_size_ptr =
      _lookup<ffi.NativeFunction<_c_opus_custom_decoder_get_size>>(
          'opus_custom_decoder_get_size');
  late final _dart_opus_custom_decoder_get_size _opus_custom_decoder_get_size =
      _opus_custom_decoder_get_size_ptr
          .asFunction<_dart_opus_custom_decoder_get_size>();

  /// Initializes a previously allocated decoder state
  /// The memory pointed to by st must be the size returned by opus_custom_decoder_get_size.
  /// This is intended for applications which use their own allocator instead of malloc.
  /// @see opus_custom_decoder_create(),opus_custom_decoder_get_size()
  /// To reset a previously initialized state use the OPUS_RESET_STATE CTL.
  /// @param [in] st <tt>OpusCustomDecoder*</tt>: Decoder state
  /// @param [in] mode <tt>OpusCustomMode *</tt>: Contains all the information about the characteristics of
  /// the stream (must be the same characteristics as used for the
  /// encoder)
  /// @param [in] channels <tt>int</tt>: Number of channels
  /// @return OPUS_OK Success or @ref opus_errorcodes
  int opus_custom_decoder_init(
    ffi.Pointer<OpusCustomDecoder> st,
    ffi.Pointer<OpusCustomMode> mode,
    int channels,
  ) {
    return _opus_custom_decoder_init(
      st,
      mode,
      channels,
    );
  }

  late final _opus_custom_decoder_init_ptr =
      _lookup<ffi.NativeFunction<_c_opus_custom_decoder_init>>(
          'opus_custom_decoder_init');
  late final _dart_opus_custom_decoder_init _opus_custom_decoder_init =
      _opus_custom_decoder_init_ptr
          .asFunction<_dart_opus_custom_decoder_init>();

  /// Creates a new decoder state. Each stream needs its own decoder state (can't
  /// be shared across simultaneous streams).
  /// @param [in] mode <tt>OpusCustomMode</tt>: Contains all the information about the characteristics of the
  /// stream (must be the same characteristics as used for the encoder)
  /// @param [in] channels <tt>int</tt>: Number of channels
  /// @param [out] error <tt>int*</tt>: Returns an error code
  /// @return Newly created decoder state.
  ffi.Pointer<OpusCustomDecoder> opus_custom_decoder_create(
    ffi.Pointer<OpusCustomMode> mode,
    int channels,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _opus_custom_decoder_create(
      mode,
      channels,
      error,
    );
  }

  late final _opus_custom_decoder_create_ptr =
      _lookup<ffi.NativeFunction<_c_opus_custom_decoder_create>>(
          'opus_custom_decoder_create');
  late final _dart_opus_custom_decoder_create _opus_custom_decoder_create =
      _opus_custom_decoder_create_ptr
          .asFunction<_dart_opus_custom_decoder_create>();

  /// Destroys a an decoder state.
  /// @param[in] st <tt>OpusCustomDecoder*</tt>: State to be freed.
  void opus_custom_decoder_destroy(
    ffi.Pointer<OpusCustomDecoder> st,
  ) {
    return _opus_custom_decoder_destroy(
      st,
    );
  }

  late final _opus_custom_decoder_destroy_ptr =
      _lookup<ffi.NativeFunction<_c_opus_custom_decoder_destroy>>(
          'opus_custom_decoder_destroy');
  late final _dart_opus_custom_decoder_destroy _opus_custom_decoder_destroy =
      _opus_custom_decoder_destroy_ptr
          .asFunction<_dart_opus_custom_decoder_destroy>();

  /// Decode an opus custom frame with floating point output
  /// @param [in] st <tt>OpusCustomDecoder*</tt>: Decoder state
  /// @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss
  /// @param [in] len <tt>int</tt>: Number of bytes in payload
  /// @param [out] pcm <tt>float*</tt>: Output signal (interleaved if 2 channels). length
  /// is frame_size*channels*sizeof(float)
  /// @param [in] frame_size Number of samples per channel of available space in *pcm.
  /// @returns Number of decoded samples or @ref opus_errorcodes
  int opus_custom_decode_float(
    ffi.Pointer<OpusCustomDecoder> st,
    ffi.Pointer<ffi.Uint8> data,
    int len,
    ffi.Pointer<ffi.Float> pcm,
    int frame_size,
  ) {
    return _opus_custom_decode_float(
      st,
      data,
      len,
      pcm,
      frame_size,
    );
  }

  late final _opus_custom_decode_float_ptr =
      _lookup<ffi.NativeFunction<_c_opus_custom_decode_float>>(
          'opus_custom_decode_float');
  late final _dart_opus_custom_decode_float _opus_custom_decode_float =
      _opus_custom_decode_float_ptr
          .asFunction<_dart_opus_custom_decode_float>();

  /// Decode an opus custom frame
  /// @param [in] st <tt>OpusCustomDecoder*</tt>: Decoder state
  /// @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss
  /// @param [in] len <tt>int</tt>: Number of bytes in payload
  /// @param [out] pcm <tt>opus_int16*</tt>: Output signal (interleaved if 2 channels). length
  /// is frame_size*channels*sizeof(opus_int16)
  /// @param [in] frame_size Number of samples per channel of available space in *pcm.
  /// @returns Number of decoded samples or @ref opus_errorcodes
  int opus_custom_decode(
    ffi.Pointer<OpusCustomDecoder> st,
    ffi.Pointer<ffi.Uint8> data,
    int len,
    ffi.Pointer<ffi.Int16> pcm,
    int frame_size,
  ) {
    return _opus_custom_decode(
      st,
      data,
      len,
      pcm,
      frame_size,
    );
  }

  late final _opus_custom_decode_ptr =
      _lookup<ffi.NativeFunction<_c_opus_custom_decode>>('opus_custom_decode');
  late final _dart_opus_custom_decode _opus_custom_decode =
      _opus_custom_decode_ptr.asFunction<_dart_opus_custom_decode>();

  /// Perform a CTL function on an Opus custom decoder.
  ///
  /// Generally the request and subsequent arguments are generated
  /// by a convenience macro.
  /// @see opus_genericctls
  int opus_custom_decoder_ctl(
    ffi.Pointer<OpusCustomDecoder> st,
    int request,
  ) {
    return _opus_custom_decoder_ctl(
      st,
      request,
    );
  }

  late final _opus_custom_decoder_ctl_ptr =
      _lookup<ffi.NativeFunction<_c_opus_custom_decoder_ctl>>(
          'opus_custom_decoder_ctl');
  late final _dart_opus_custom_decoder_ctl _opus_custom_decoder_ctl =
      _opus_custom_decoder_ctl_ptr.asFunction<_dart_opus_custom_decoder_ctl>();

  /// Gets the size of an <code>OpusEncoder</code> structure.
  /// @param[in] channels <tt>int</tt>: Number of channels.
  /// This must be 1 or 2.
  /// @returns The size in bytes.
  int opus_encoder_get_size(
    int channels,
  ) {
    return _opus_encoder_get_size(
      channels,
    );
  }

  late final _opus_encoder_get_size_ptr =
      _lookup<ffi.NativeFunction<_c_opus_encoder_get_size>>(
          'opus_encoder_get_size');
  late final _dart_opus_encoder_get_size _opus_encoder_get_size =
      _opus_encoder_get_size_ptr.asFunction<_dart_opus_encoder_get_size>();

  /// Allocates and initializes an encoder state.
  /// There are three coding modes:
  ///
  /// @ref OPUS_APPLICATION_VOIP gives best quality at a given bitrate for voice
  /// signals. It enhances the  input signal by high-pass filtering and
  /// emphasizing formants and harmonics. Optionally  it includes in-band
  /// forward error correction to protect against packet loss. Use this
  /// mode for typical VoIP applications. Because of the enhancement,
  /// even at high bitrates the output may sound different from the input.
  ///
  /// @ref OPUS_APPLICATION_AUDIO gives best quality at a given bitrate for most
  /// non-voice signals like music. Use this mode for music and mixed
  /// (music/voice) content, broadcast, and applications requiring less
  /// than 15 ms of coding delay.
  ///
  /// @ref OPUS_APPLICATION_RESTRICTED_LOWDELAY configures low-delay mode that
  /// disables the speech-optimized mode in exchange for slightly reduced delay.
  /// This mode can only be set on an newly initialized or freshly reset encoder
  /// because it changes the codec delay.
  ///
  /// This is useful when the caller knows that the speech-optimized modes will not be needed (use with caution).
  /// @param [in] Fs <tt>opus_int32</tt>: Sampling rate of input signal (Hz)
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param [in] channels <tt>int</tt>: Number of channels (1 or 2) in input signal
  /// @param [in] application <tt>int</tt>: Coding mode (@ref OPUS_APPLICATION_VOIP/@ref OPUS_APPLICATION_AUDIO/@ref OPUS_APPLICATION_RESTRICTED_LOWDELAY)
  /// @param [out] error <tt>int*</tt>: @ref opus_errorcodes
  /// @note Regardless of the sampling rate and number channels selected, the Opus encoder
  /// can switch to a lower audio bandwidth or number of channels if the bitrate
  /// selected is too low. This also means that it is safe to always use 48 kHz stereo input
  /// and let the encoder optimize the encoding.
  ffi.Pointer<OpusEncoder> opus_encoder_create(
    int Fs,
    int channels,
    int application,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _opus_encoder_create(
      Fs,
      channels,
      application,
      error,
    );
  }

  late final _opus_encoder_create_ptr =
      _lookup<ffi.NativeFunction<_c_opus_encoder_create>>(
          'opus_encoder_create');
  late final _dart_opus_encoder_create _opus_encoder_create =
      _opus_encoder_create_ptr.asFunction<_dart_opus_encoder_create>();

  /// Initializes a previously allocated encoder state
  /// The memory pointed to by st must be at least the size returned by opus_encoder_get_size().
  /// This is intended for applications which use their own allocator instead of malloc.
  /// @see opus_encoder_create(),opus_encoder_get_size()
  /// To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.
  /// @param [in] st <tt>OpusEncoder*</tt>: Encoder state
  /// @param [in] Fs <tt>opus_int32</tt>: Sampling rate of input signal (Hz)
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param [in] channels <tt>int</tt>: Number of channels (1 or 2) in input signal
  /// @param [in] application <tt>int</tt>: Coding mode (OPUS_APPLICATION_VOIP/OPUS_APPLICATION_AUDIO/OPUS_APPLICATION_RESTRICTED_LOWDELAY)
  /// @retval #OPUS_OK Success or @ref opus_errorcodes
  int opus_encoder_init(
    ffi.Pointer<OpusEncoder> st,
    int Fs,
    int channels,
    int application,
  ) {
    return _opus_encoder_init(
      st,
      Fs,
      channels,
      application,
    );
  }

  late final _opus_encoder_init_ptr =
      _lookup<ffi.NativeFunction<_c_opus_encoder_init>>('opus_encoder_init');
  late final _dart_opus_encoder_init _opus_encoder_init =
      _opus_encoder_init_ptr.asFunction<_dart_opus_encoder_init>();

  /// Encodes an Opus frame.
  /// @param [in] st <tt>OpusEncoder*</tt>: Encoder state
  /// @param [in] pcm <tt>opus_int16*</tt>: Input signal (interleaved if 2 channels). length is frame_size*channels*sizeof(opus_int16)
  /// @param [in] frame_size <tt>int</tt>: Number of samples per channel in the
  /// input signal.
  /// This must be an Opus frame size for
  /// the encoder's sampling rate.
  /// For example, at 48 kHz the permitted
  /// values are 120, 240, 480, 960, 1920,
  /// and 2880.
  /// Passing in a duration of less than
  /// 10 ms (480 samples at 48 kHz) will
  /// prevent the encoder from using the LPC
  /// or hybrid modes.
  /// @param [out] data <tt>unsigned char*</tt>: Output payload.
  /// This must contain storage for at
  /// least \a max_data_bytes.
  /// @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated
  /// memory for the output
  /// payload. This may be
  /// used to impose an upper limit on
  /// the instant bitrate, but should
  /// not be used as the only bitrate
  /// control. Use #OPUS_SET_BITRATE to
  /// control the bitrate.
  /// @returns The length of the encoded packet (in bytes) on success or a
  /// negative error code (see @ref opus_errorcodes) on failure.
  int opus_encode(
    ffi.Pointer<OpusEncoder> st,
    ffi.Pointer<ffi.Int16> pcm,
    int frame_size,
    ffi.Pointer<ffi.Uint8> data,
    int max_data_bytes,
  ) {
    return _opus_encode(
      st,
      pcm,
      frame_size,
      data,
      max_data_bytes,
    );
  }

  late final _opus_encode_ptr =
      _lookup<ffi.NativeFunction<_c_opus_encode>>('opus_encode');
  late final _dart_opus_encode _opus_encode =
      _opus_encode_ptr.asFunction<_dart_opus_encode>();

  /// Encodes an Opus frame from floating point input.
  /// @param [in] st <tt>OpusEncoder*</tt>: Encoder state
  /// @param [in] pcm <tt>float*</tt>: Input in float format (interleaved if 2 channels), with a normal range of +/-1.0.
  /// Samples with a range beyond +/-1.0 are supported but will
  /// be clipped by decoders using the integer API and should
  /// only be used if it is known that the far end supports
  /// extended dynamic range.
  /// length is frame_size*channels*sizeof(float)
  /// @param [in] frame_size <tt>int</tt>: Number of samples per channel in the
  /// input signal.
  /// This must be an Opus frame size for
  /// the encoder's sampling rate.
  /// For example, at 48 kHz the permitted
  /// values are 120, 240, 480, 960, 1920,
  /// and 2880.
  /// Passing in a duration of less than
  /// 10 ms (480 samples at 48 kHz) will
  /// prevent the encoder from using the LPC
  /// or hybrid modes.
  /// @param [out] data <tt>unsigned char*</tt>: Output payload.
  /// This must contain storage for at
  /// least \a max_data_bytes.
  /// @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated
  /// memory for the output
  /// payload. This may be
  /// used to impose an upper limit on
  /// the instant bitrate, but should
  /// not be used as the only bitrate
  /// control. Use #OPUS_SET_BITRATE to
  /// control the bitrate.
  /// @returns The length of the encoded packet (in bytes) on success or a
  /// negative error code (see @ref opus_errorcodes) on failure.
  int opus_encode_float(
    ffi.Pointer<OpusEncoder> st,
    ffi.Pointer<ffi.Float> pcm,
    int frame_size,
    ffi.Pointer<ffi.Uint8> data,
    int max_data_bytes,
  ) {
    return _opus_encode_float(
      st,
      pcm,
      frame_size,
      data,
      max_data_bytes,
    );
  }

  late final _opus_encode_float_ptr =
      _lookup<ffi.NativeFunction<_c_opus_encode_float>>('opus_encode_float');
  late final _dart_opus_encode_float _opus_encode_float =
      _opus_encode_float_ptr.asFunction<_dart_opus_encode_float>();

  /// Frees an <code>OpusEncoder</code> allocated by opus_encoder_create().
  /// @param[in] st <tt>OpusEncoder*</tt>: State to be freed.
  void opus_encoder_destroy(
    ffi.Pointer<OpusEncoder> st,
  ) {
    return _opus_encoder_destroy(
      st,
    );
  }

  late final _opus_encoder_destroy_ptr =
      _lookup<ffi.NativeFunction<_c_opus_encoder_destroy>>(
          'opus_encoder_destroy');
  late final _dart_opus_encoder_destroy _opus_encoder_destroy =
      _opus_encoder_destroy_ptr.asFunction<_dart_opus_encoder_destroy>();

  /// Perform a CTL function on an Opus encoder.
  ///
  /// Generally the request and subsequent arguments are generated
  /// by a convenience macro.
  /// @param st <tt>OpusEncoder*</tt>: Encoder state.
  /// @param request This and all remaining parameters should be replaced by one
  /// of the convenience macros in @ref opus_genericctls or
  /// @ref opus_encoderctls.
  /// @see opus_genericctls
  /// @see opus_encoderctls
  int opus_encoder_ctl(
    ffi.Pointer<OpusEncoder> st,
    int request,
  ) {
    return _opus_encoder_ctl(
      st,
      request,
    );
  }

  late final _opus_encoder_ctl_ptr =
      _lookup<ffi.NativeFunction<_c_opus_encoder_ctl>>('opus_encoder_ctl');
  late final _dart_opus_encoder_ctl _opus_encoder_ctl =
      _opus_encoder_ctl_ptr.asFunction<_dart_opus_encoder_ctl>();

  /// Gets the size of an <code>OpusDecoder</code> structure.
  /// @param [in] channels <tt>int</tt>: Number of channels.
  /// This must be 1 or 2.
  /// @returns The size in bytes.
  int opus_decoder_get_size(
    int channels,
  ) {
    return _opus_decoder_get_size(
      channels,
    );
  }

  late final _opus_decoder_get_size_ptr =
      _lookup<ffi.NativeFunction<_c_opus_decoder_get_size>>(
          'opus_decoder_get_size');
  late final _dart_opus_decoder_get_size _opus_decoder_get_size =
      _opus_decoder_get_size_ptr.asFunction<_dart_opus_decoder_get_size>();

  /// Allocates and initializes a decoder state.
  /// @param [in] Fs <tt>opus_int32</tt>: Sample rate to decode at (Hz).
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param [in] channels <tt>int</tt>: Number of channels (1 or 2) to decode
  /// @param [out] error <tt>int*</tt>: #OPUS_OK Success or @ref opus_errorcodes
  ///
  /// Internally Opus stores data at 48000 Hz, so that should be the default
  /// value for Fs. However, the decoder can efficiently decode to buffers
  /// at 8, 12, 16, and 24 kHz so if for some reason the caller cannot use
  /// data at the full sample rate, or knows the compressed data doesn't
  /// use the full frequency range, it can request decoding at a reduced
  /// rate. Likewise, the decoder is capable of filling in either mono or
  /// interleaved stereo pcm buffers, at the caller's request.
  ffi.Pointer<OpusDecoder> opus_decoder_create(
    int Fs,
    int channels,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _opus_decoder_create(
      Fs,
      channels,
      error,
    );
  }

  late final _opus_decoder_create_ptr =
      _lookup<ffi.NativeFunction<_c_opus_decoder_create>>(
          'opus_decoder_create');
  late final _dart_opus_decoder_create _opus_decoder_create =
      _opus_decoder_create_ptr.asFunction<_dart_opus_decoder_create>();

  /// Initializes a previously allocated decoder state.
  /// The state must be at least the size returned by opus_decoder_get_size().
  /// This is intended for applications which use their own allocator instead of malloc. @see opus_decoder_create,opus_decoder_get_size
  /// To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.
  /// @param [in] st <tt>OpusDecoder*</tt>: Decoder state.
  /// @param [in] Fs <tt>opus_int32</tt>: Sampling rate to decode to (Hz).
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param [in] channels <tt>int</tt>: Number of channels (1 or 2) to decode
  /// @retval #OPUS_OK Success or @ref opus_errorcodes
  int opus_decoder_init(
    ffi.Pointer<OpusDecoder> st,
    int Fs,
    int channels,
  ) {
    return _opus_decoder_init(
      st,
      Fs,
      channels,
    );
  }

  late final _opus_decoder_init_ptr =
      _lookup<ffi.NativeFunction<_c_opus_decoder_init>>('opus_decoder_init');
  late final _dart_opus_decoder_init _opus_decoder_init =
      _opus_decoder_init_ptr.asFunction<_dart_opus_decoder_init>();

  /// Decode an Opus packet.
  /// @param [in] st <tt>OpusDecoder*</tt>: Decoder state
  /// @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss
  /// @param [in] len <tt>opus_int32</tt>: Number of bytes in payload*
  /// @param [out] pcm <tt>opus_int16*</tt>: Output signal (interleaved if 2 channels). length
  /// is frame_size*channels*sizeof(opus_int16)
  /// @param [in] frame_size Number of samples per channel of available space in \a pcm.
  /// If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will
  /// not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),
  /// then frame_size needs to be exactly the duration of audio that is missing, otherwise the
  /// decoder will not be in the optimal state to decode the next incoming packet. For the PLC and
  /// FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.
  /// @param [in] decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be
  /// decoded. If no such data is available, the frame is decoded as if it were lost.
  /// @returns Number of decoded samples or @ref opus_errorcodes
  int opus_decode(
    ffi.Pointer<OpusDecoder> st,
    ffi.Pointer<ffi.Uint8> data,
    int len,
    ffi.Pointer<ffi.Int16> pcm,
    int frame_size,
    int decode_fec,
  ) {
    return _opus_decode(
      st,
      data,
      len,
      pcm,
      frame_size,
      decode_fec,
    );
  }

  late final _opus_decode_ptr =
      _lookup<ffi.NativeFunction<_c_opus_decode>>('opus_decode');
  late final _dart_opus_decode _opus_decode =
      _opus_decode_ptr.asFunction<_dart_opus_decode>();

  /// Decode an Opus packet with floating point output.
  /// @param [in] st <tt>OpusDecoder*</tt>: Decoder state
  /// @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss
  /// @param [in] len <tt>opus_int32</tt>: Number of bytes in payload
  /// @param [out] pcm <tt>float*</tt>: Output signal (interleaved if 2 channels). length
  /// is frame_size*channels*sizeof(float)
  /// @param [in] frame_size Number of samples per channel of available space in \a pcm.
  /// If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will
  /// not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),
  /// then frame_size needs to be exactly the duration of audio that is missing, otherwise the
  /// decoder will not be in the optimal state to decode the next incoming packet. For the PLC and
  /// FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.
  /// @param [in] decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be
  /// decoded. If no such data is available the frame is decoded as if it were lost.
  /// @returns Number of decoded samples or @ref opus_errorcodes
  int opus_decode_float(
    ffi.Pointer<OpusDecoder> st,
    ffi.Pointer<ffi.Uint8> data,
    int len,
    ffi.Pointer<ffi.Float> pcm,
    int frame_size,
    int decode_fec,
  ) {
    return _opus_decode_float(
      st,
      data,
      len,
      pcm,
      frame_size,
      decode_fec,
    );
  }

  late final _opus_decode_float_ptr =
      _lookup<ffi.NativeFunction<_c_opus_decode_float>>('opus_decode_float');
  late final _dart_opus_decode_float _opus_decode_float =
      _opus_decode_float_ptr.asFunction<_dart_opus_decode_float>();

  /// Perform a CTL function on an Opus decoder.
  ///
  /// Generally the request and subsequent arguments are generated
  /// by a convenience macro.
  /// @param st <tt>OpusDecoder*</tt>: Decoder state.
  /// @param request This and all remaining parameters should be replaced by one
  /// of the convenience macros in @ref opus_genericctls or
  /// @ref opus_decoderctls.
  /// @see opus_genericctls
  /// @see opus_decoderctls
  int opus_decoder_ctl(
    ffi.Pointer<OpusDecoder> st,
    int request,
  ) {
    return _opus_decoder_ctl(
      st,
      request,
    );
  }

  late final _opus_decoder_ctl_ptr =
      _lookup<ffi.NativeFunction<_c_opus_decoder_ctl>>('opus_decoder_ctl');
  late final _dart_opus_decoder_ctl _opus_decoder_ctl =
      _opus_decoder_ctl_ptr.asFunction<_dart_opus_decoder_ctl>();

  /// Frees an <code>OpusDecoder</code> allocated by opus_decoder_create().
  /// @param[in] st <tt>OpusDecoder*</tt>: State to be freed.
  void opus_decoder_destroy(
    ffi.Pointer<OpusDecoder> st,
  ) {
    return _opus_decoder_destroy(
      st,
    );
  }

  late final _opus_decoder_destroy_ptr =
      _lookup<ffi.NativeFunction<_c_opus_decoder_destroy>>(
          'opus_decoder_destroy');
  late final _dart_opus_decoder_destroy _opus_decoder_destroy =
      _opus_decoder_destroy_ptr.asFunction<_dart_opus_decoder_destroy>();

  /// Parse an opus packet into one or more frames.
  /// Opus_decode will perform this operation internally so most applications do
  /// not need to use this function.
  /// This function does not copy the frames, the returned pointers are pointers into
  /// the input packet.
  /// @param [in] data <tt>char*</tt>: Opus packet to be parsed
  /// @param [in] len <tt>opus_int32</tt>: size of data
  /// @param [out] out_toc <tt>char*</tt>: TOC pointer
  /// @param [out] frames <tt>char*[48]</tt> encapsulated frames
  /// @param [out] size <tt>opus_int16[48]</tt> sizes of the encapsulated frames
  /// @param [out] payload_offset <tt>int*</tt>: returns the position of the payload within the packet (in bytes)
  /// @returns number of frames
  int opus_packet_parse(
    ffi.Pointer<ffi.Uint8> data,
    int len,
    ffi.Pointer<ffi.Uint8> out_toc,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> frames,
    ffi.Pointer<ffi.Int16> size,
    ffi.Pointer<ffi.Int32> payload_offset,
  ) {
    return _opus_packet_parse(
      data,
      len,
      out_toc,
      frames,
      size,
      payload_offset,
    );
  }

  late final _opus_packet_parse_ptr =
      _lookup<ffi.NativeFunction<_c_opus_packet_parse>>('opus_packet_parse');
  late final _dart_opus_packet_parse _opus_packet_parse =
      _opus_packet_parse_ptr.asFunction<_dart_opus_packet_parse>();

  /// Gets the bandwidth of an Opus packet.
  /// @param [in] data <tt>char*</tt>: Opus packet
  /// @retval OPUS_BANDWIDTH_NARROWBAND Narrowband (4kHz bandpass)
  /// @retval OPUS_BANDWIDTH_MEDIUMBAND Mediumband (6kHz bandpass)
  /// @retval OPUS_BANDWIDTH_WIDEBAND Wideband (8kHz bandpass)
  /// @retval OPUS_BANDWIDTH_SUPERWIDEBAND Superwideband (12kHz bandpass)
  /// @retval OPUS_BANDWIDTH_FULLBAND Fullband (20kHz bandpass)
  /// @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type
  int opus_packet_get_bandwidth(
    ffi.Pointer<ffi.Uint8> data,
  ) {
    return _opus_packet_get_bandwidth(
      data,
    );
  }

  late final _opus_packet_get_bandwidth_ptr =
      _lookup<ffi.NativeFunction<_c_opus_packet_get_bandwidth>>(
          'opus_packet_get_bandwidth');
  late final _dart_opus_packet_get_bandwidth _opus_packet_get_bandwidth =
      _opus_packet_get_bandwidth_ptr
          .asFunction<_dart_opus_packet_get_bandwidth>();

  /// Gets the number of samples per frame from an Opus packet.
  /// @param [in] data <tt>char*</tt>: Opus packet.
  /// This must contain at least one byte of
  /// data.
  /// @param [in] Fs <tt>opus_int32</tt>: Sampling rate in Hz.
  /// This must be a multiple of 400, or
  /// inaccurate results will be returned.
  /// @returns Number of samples per frame.
  int opus_packet_get_samples_per_frame(
    ffi.Pointer<ffi.Uint8> data,
    int Fs,
  ) {
    return _opus_packet_get_samples_per_frame(
      data,
      Fs,
    );
  }

  late final _opus_packet_get_samples_per_frame_ptr =
      _lookup<ffi.NativeFunction<_c_opus_packet_get_samples_per_frame>>(
          'opus_packet_get_samples_per_frame');
  late final _dart_opus_packet_get_samples_per_frame
      _opus_packet_get_samples_per_frame =
      _opus_packet_get_samples_per_frame_ptr
          .asFunction<_dart_opus_packet_get_samples_per_frame>();

  /// Gets the number of channels from an Opus packet.
  /// @param [in] data <tt>char*</tt>: Opus packet
  /// @returns Number of channels
  /// @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type
  int opus_packet_get_nb_channels(
    ffi.Pointer<ffi.Uint8> data,
  ) {
    return _opus_packet_get_nb_channels(
      data,
    );
  }

  late final _opus_packet_get_nb_channels_ptr =
      _lookup<ffi.NativeFunction<_c_opus_packet_get_nb_channels>>(
          'opus_packet_get_nb_channels');
  late final _dart_opus_packet_get_nb_channels _opus_packet_get_nb_channels =
      _opus_packet_get_nb_channels_ptr
          .asFunction<_dart_opus_packet_get_nb_channels>();

  /// Gets the number of frames in an Opus packet.
  /// @param [in] packet <tt>char*</tt>: Opus packet
  /// @param [in] len <tt>opus_int32</tt>: Length of packet
  /// @returns Number of frames
  /// @retval OPUS_BAD_ARG Insufficient data was passed to the function
  /// @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type
  int opus_packet_get_nb_frames(
    ffi.Pointer<ffi.Uint8> packet,
    int len,
  ) {
    return _opus_packet_get_nb_frames(
      packet,
      len,
    );
  }

  late final _opus_packet_get_nb_frames_ptr =
      _lookup<ffi.NativeFunction<_c_opus_packet_get_nb_frames>>(
          'opus_packet_get_nb_frames');
  late final _dart_opus_packet_get_nb_frames _opus_packet_get_nb_frames =
      _opus_packet_get_nb_frames_ptr
          .asFunction<_dart_opus_packet_get_nb_frames>();

  /// Gets the number of samples of an Opus packet.
  /// @param [in] packet <tt>char*</tt>: Opus packet
  /// @param [in] len <tt>opus_int32</tt>: Length of packet
  /// @param [in] Fs <tt>opus_int32</tt>: Sampling rate in Hz.
  /// This must be a multiple of 400, or
  /// inaccurate results will be returned.
  /// @returns Number of samples
  /// @retval OPUS_BAD_ARG Insufficient data was passed to the function
  /// @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type
  int opus_packet_get_nb_samples(
    ffi.Pointer<ffi.Uint8> packet,
    int len,
    int Fs,
  ) {
    return _opus_packet_get_nb_samples(
      packet,
      len,
      Fs,
    );
  }

  late final _opus_packet_get_nb_samples_ptr =
      _lookup<ffi.NativeFunction<_c_opus_packet_get_nb_samples>>(
          'opus_packet_get_nb_samples');
  late final _dart_opus_packet_get_nb_samples _opus_packet_get_nb_samples =
      _opus_packet_get_nb_samples_ptr
          .asFunction<_dart_opus_packet_get_nb_samples>();

  /// Gets the number of samples of an Opus packet.
  /// @param [in] dec <tt>OpusDecoder*</tt>: Decoder state
  /// @param [in] packet <tt>char*</tt>: Opus packet
  /// @param [in] len <tt>opus_int32</tt>: Length of packet
  /// @returns Number of samples
  /// @retval OPUS_BAD_ARG Insufficient data was passed to the function
  /// @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type
  int opus_decoder_get_nb_samples(
    ffi.Pointer<OpusDecoder> dec,
    ffi.Pointer<ffi.Uint8> packet,
    int len,
  ) {
    return _opus_decoder_get_nb_samples(
      dec,
      packet,
      len,
    );
  }

  late final _opus_decoder_get_nb_samples_ptr =
      _lookup<ffi.NativeFunction<_c_opus_decoder_get_nb_samples>>(
          'opus_decoder_get_nb_samples');
  late final _dart_opus_decoder_get_nb_samples _opus_decoder_get_nb_samples =
      _opus_decoder_get_nb_samples_ptr
          .asFunction<_dart_opus_decoder_get_nb_samples>();

  /// Applies soft-clipping to bring a float signal within the [-1,1] range. If
  /// the signal is already in that range, nothing is done. If there are values
  /// outside of [-1,1], then the signal is clipped as smoothly as possible to
  /// both fit in the range and avoid creating excessive distortion in the
  /// process.
  /// @param [in,out] pcm <tt>float*</tt>: Input PCM and modified PCM
  /// @param [in] frame_size <tt>int</tt> Number of samples per channel to process
  /// @param [in] channels <tt>int</tt>: Number of channels
  /// @param [in,out] softclip_mem <tt>float*</tt>: State memory for the soft clipping process (one float per channel, initialized to zero)
  void opus_pcm_soft_clip(
    ffi.Pointer<ffi.Float> pcm,
    int frame_size,
    int channels,
    ffi.Pointer<ffi.Float> softclip_mem,
  ) {
    return _opus_pcm_soft_clip(
      pcm,
      frame_size,
      channels,
      softclip_mem,
    );
  }

  late final _opus_pcm_soft_clip_ptr =
      _lookup<ffi.NativeFunction<_c_opus_pcm_soft_clip>>('opus_pcm_soft_clip');
  late final _dart_opus_pcm_soft_clip _opus_pcm_soft_clip =
      _opus_pcm_soft_clip_ptr.asFunction<_dart_opus_pcm_soft_clip>();

  /// Gets the size of an <code>OpusRepacketizer</code> structure.
  /// @returns The size in bytes.
  int opus_repacketizer_get_size() {
    return _opus_repacketizer_get_size();
  }

  late final _opus_repacketizer_get_size_ptr =
      _lookup<ffi.NativeFunction<_c_opus_repacketizer_get_size>>(
          'opus_repacketizer_get_size');
  late final _dart_opus_repacketizer_get_size _opus_repacketizer_get_size =
      _opus_repacketizer_get_size_ptr
          .asFunction<_dart_opus_repacketizer_get_size>();

  /// (Re)initializes a previously allocated repacketizer state.
  /// The state must be at least the size returned by opus_repacketizer_get_size().
  /// This can be used for applications which use their own allocator instead of
  /// malloc().
  /// It must also be called to reset the queue of packets waiting to be
  /// repacketized, which is necessary if the maximum packet duration of 120 ms
  /// is reached or if you wish to submit packets with a different Opus
  /// configuration (coding mode, audio bandwidth, frame size, or channel count).
  /// Failure to do so will prevent a new packet from being added with
  /// opus_repacketizer_cat().
  /// @see opus_repacketizer_create
  /// @see opus_repacketizer_get_size
  /// @see opus_repacketizer_cat
  /// @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state to
  /// (re)initialize.
  /// @returns A pointer to the same repacketizer state that was passed in.
  ffi.Pointer<OpusRepacketizer> opus_repacketizer_init(
    ffi.Pointer<OpusRepacketizer> rp,
  ) {
    return _opus_repacketizer_init(
      rp,
    );
  }

  late final _opus_repacketizer_init_ptr =
      _lookup<ffi.NativeFunction<_c_opus_repacketizer_init>>(
          'opus_repacketizer_init');
  late final _dart_opus_repacketizer_init _opus_repacketizer_init =
      _opus_repacketizer_init_ptr.asFunction<_dart_opus_repacketizer_init>();

  /// Allocates memory and initializes the new repacketizer with
  /// opus_repacketizer_init().
  ffi.Pointer<OpusRepacketizer> opus_repacketizer_create() {
    return _opus_repacketizer_create();
  }

  late final _opus_repacketizer_create_ptr =
      _lookup<ffi.NativeFunction<_c_opus_repacketizer_create>>(
          'opus_repacketizer_create');
  late final _dart_opus_repacketizer_create _opus_repacketizer_create =
      _opus_repacketizer_create_ptr
          .asFunction<_dart_opus_repacketizer_create>();

  /// Frees an <code>OpusRepacketizer</code> allocated by
  /// opus_repacketizer_create().
  /// @param[in] rp <tt>OpusRepacketizer*</tt>: State to be freed.
  void opus_repacketizer_destroy(
    ffi.Pointer<OpusRepacketizer> rp,
  ) {
    return _opus_repacketizer_destroy(
      rp,
    );
  }

  late final _opus_repacketizer_destroy_ptr =
      _lookup<ffi.NativeFunction<_c_opus_repacketizer_destroy>>(
          'opus_repacketizer_destroy');
  late final _dart_opus_repacketizer_destroy _opus_repacketizer_destroy =
      _opus_repacketizer_destroy_ptr
          .asFunction<_dart_opus_repacketizer_destroy>();

  /// Add a packet to the current repacketizer state.
  /// This packet must match the configuration of any packets already submitted
  /// for repacketization since the last call to opus_repacketizer_init().
  /// This means that it must have the same coding mode, audio bandwidth, frame
  /// size, and channel count.
  /// This can be checked in advance by examining the top 6 bits of the first
  /// byte of the packet, and ensuring they match the top 6 bits of the first
  /// byte of any previously submitted packet.
  /// The total duration of audio in the repacketizer state also must not exceed
  /// 120 ms, the maximum duration of a single packet, after adding this packet.
  ///
  /// The contents of the current repacketizer state can be extracted into new
  /// packets using opus_repacketizer_out() or opus_repacketizer_out_range().
  ///
  /// In order to add a packet with a different configuration or to add more
  /// audio beyond 120 ms, you must clear the repacketizer state by calling
  /// opus_repacketizer_init().
  /// If a packet is too large to add to the current repacketizer state, no part
  /// of it is added, even if it contains multiple frames, some of which might
  /// fit.
  /// If you wish to be able to add parts of such packets, you should first use
  /// another repacketizer to split the packet into pieces and add them
  /// individually.
  /// @see opus_repacketizer_out_range
  /// @see opus_repacketizer_out
  /// @see opus_repacketizer_init
  /// @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state to which to
  /// add the packet.
  /// @param[in] data <tt>const unsigned char*</tt>: The packet data.
  /// The application must ensure
  /// this pointer remains valid
  /// until the next call to
  /// opus_repacketizer_init() or
  /// opus_repacketizer_destroy().
  /// @param len <tt>opus_int32</tt>: The number of bytes in the packet data.
  /// @returns An error code indicating whether or not the operation succeeded.
  /// @retval #OPUS_OK The packet's contents have been added to the repacketizer
  /// state.
  /// @retval #OPUS_INVALID_PACKET The packet did not have a valid TOC sequence,
  /// the packet's TOC sequence was not compatible
  /// with previously submitted packets (because
  /// the coding mode, audio bandwidth, frame size,
  /// or channel count did not match), or adding
  /// this packet would increase the total amount of
  /// audio stored in the repacketizer state to more
  /// than 120 ms.
  int opus_repacketizer_cat(
    ffi.Pointer<OpusRepacketizer> rp,
    ffi.Pointer<ffi.Uint8> data,
    int len,
  ) {
    return _opus_repacketizer_cat(
      rp,
      data,
      len,
    );
  }

  late final _opus_repacketizer_cat_ptr =
      _lookup<ffi.NativeFunction<_c_opus_repacketizer_cat>>(
          'opus_repacketizer_cat');
  late final _dart_opus_repacketizer_cat _opus_repacketizer_cat =
      _opus_repacketizer_cat_ptr.asFunction<_dart_opus_repacketizer_cat>();

  /// Construct a new packet from data previously submitted to the repacketizer
  /// state via opus_repacketizer_cat().
  /// @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state from which to
  /// construct the new packet.
  /// @param begin <tt>int</tt>: The index of the first frame in the current
  /// repacketizer state to include in the output.
  /// @param end <tt>int</tt>: One past the index of the last frame in the
  /// current repacketizer state to include in the
  /// output.
  /// @param[out] data <tt>const unsigned char*</tt>: The buffer in which to
  /// store the output packet.
  /// @param maxlen <tt>opus_int32</tt>: The maximum number of bytes to store in
  /// the output buffer. In order to guarantee
  /// success, this should be at least
  /// <code>1276</code> for a single frame,
  /// or for multiple frames,
  /// <code>1277*(end-begin)</code>.
  /// However, <code>1*(end-begin)</code> plus
  /// the size of all packet data submitted to
  /// the repacketizer since the last call to
  /// opus_repacketizer_init() or
  /// opus_repacketizer_create() is also
  /// sufficient, and possibly much smaller.
  /// @returns The total size of the output packet on success, or an error code
  /// on failure.
  /// @retval #OPUS_BAD_ARG <code>[begin,end)</code> was an invalid range of
  /// frames (begin < 0, begin >= end, or end >
  /// opus_repacketizer_get_nb_frames()).
  /// @retval #OPUS_BUFFER_TOO_SMALL \a maxlen was insufficient to contain the
  /// complete output packet.
  int opus_repacketizer_out_range(
    ffi.Pointer<OpusRepacketizer> rp,
    int begin,
    int end,
    ffi.Pointer<ffi.Uint8> data,
    int maxlen,
  ) {
    return _opus_repacketizer_out_range(
      rp,
      begin,
      end,
      data,
      maxlen,
    );
  }

  late final _opus_repacketizer_out_range_ptr =
      _lookup<ffi.NativeFunction<_c_opus_repacketizer_out_range>>(
          'opus_repacketizer_out_range');
  late final _dart_opus_repacketizer_out_range _opus_repacketizer_out_range =
      _opus_repacketizer_out_range_ptr
          .asFunction<_dart_opus_repacketizer_out_range>();

  /// Return the total number of frames contained in packet data submitted to
  /// the repacketizer state so far via opus_repacketizer_cat() since the last
  /// call to opus_repacketizer_init() or opus_repacketizer_create().
  /// This defines the valid range of packets that can be extracted with
  /// opus_repacketizer_out_range() or opus_repacketizer_out().
  /// @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state containing the
  /// frames.
  /// @returns The total number of frames contained in the packet data submitted
  /// to the repacketizer state.
  int opus_repacketizer_get_nb_frames(
    ffi.Pointer<OpusRepacketizer> rp,
  ) {
    return _opus_repacketizer_get_nb_frames(
      rp,
    );
  }

  late final _opus_repacketizer_get_nb_frames_ptr =
      _lookup<ffi.NativeFunction<_c_opus_repacketizer_get_nb_frames>>(
          'opus_repacketizer_get_nb_frames');
  late final _dart_opus_repacketizer_get_nb_frames
      _opus_repacketizer_get_nb_frames = _opus_repacketizer_get_nb_frames_ptr
          .asFunction<_dart_opus_repacketizer_get_nb_frames>();

  /// Construct a new packet from data previously submitted to the repacketizer
  /// state via opus_repacketizer_cat().
  /// This is a convenience routine that returns all the data submitted so far
  /// in a single packet.
  /// It is equivalent to calling
  /// @code
  /// opus_repacketizer_out_range(rp, 0, opus_repacketizer_get_nb_frames(rp),
  /// data, maxlen)
  /// @endcode
  /// @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state from which to
  /// construct the new packet.
  /// @param[out] data <tt>const unsigned char*</tt>: The buffer in which to
  /// store the output packet.
  /// @param maxlen <tt>opus_int32</tt>: The maximum number of bytes to store in
  /// the output buffer. In order to guarantee
  /// success, this should be at least
  /// <code>1277*opus_repacketizer_get_nb_frames(rp)</code>.
  /// However,
  /// <code>1*opus_repacketizer_get_nb_frames(rp)</code>
  /// plus the size of all packet data
  /// submitted to the repacketizer since the
  /// last call to opus_repacketizer_init() or
  /// opus_repacketizer_create() is also
  /// sufficient, and possibly much smaller.
  /// @returns The total size of the output packet on success, or an error code
  /// on failure.
  /// @retval #OPUS_BUFFER_TOO_SMALL \a maxlen was insufficient to contain the
  /// complete output packet.
  int opus_repacketizer_out(
    ffi.Pointer<OpusRepacketizer> rp,
    ffi.Pointer<ffi.Uint8> data,
    int maxlen,
  ) {
    return _opus_repacketizer_out(
      rp,
      data,
      maxlen,
    );
  }

  late final _opus_repacketizer_out_ptr =
      _lookup<ffi.NativeFunction<_c_opus_repacketizer_out>>(
          'opus_repacketizer_out');
  late final _dart_opus_repacketizer_out _opus_repacketizer_out =
      _opus_repacketizer_out_ptr.asFunction<_dart_opus_repacketizer_out>();

  /// Pads a given Opus packet to a larger size (possibly changing the TOC sequence).
  /// @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the
  /// packet to pad.
  /// @param len <tt>opus_int32</tt>: The size of the packet.
  /// This must be at least 1.
  /// @param new_len <tt>opus_int32</tt>: The desired size of the packet after padding.
  /// This must be at least as large as len.
  /// @returns an error code
  /// @retval #OPUS_OK \a on success.
  /// @retval #OPUS_BAD_ARG \a len was less than 1 or new_len was less than len.
  /// @retval #OPUS_INVALID_PACKET \a data did not contain a valid Opus packet.
  int opus_packet_pad(
    ffi.Pointer<ffi.Uint8> data,
    int len,
    int new_len,
  ) {
    return _opus_packet_pad(
      data,
      len,
      new_len,
    );
  }

  late final _opus_packet_pad_ptr =
      _lookup<ffi.NativeFunction<_c_opus_packet_pad>>('opus_packet_pad');
  late final _dart_opus_packet_pad _opus_packet_pad =
      _opus_packet_pad_ptr.asFunction<_dart_opus_packet_pad>();

  /// Remove all padding from a given Opus packet and rewrite the TOC sequence to
  /// minimize space usage.
  /// @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the
  /// packet to strip.
  /// @param len <tt>opus_int32</tt>: The size of the packet.
  /// This must be at least 1.
  /// @returns The new size of the output packet on success, or an error code
  /// on failure.
  /// @retval #OPUS_BAD_ARG \a len was less than 1.
  /// @retval #OPUS_INVALID_PACKET \a data did not contain a valid Opus packet.
  int opus_packet_unpad(
    ffi.Pointer<ffi.Uint8> data,
    int len,
  ) {
    return _opus_packet_unpad(
      data,
      len,
    );
  }

  late final _opus_packet_unpad_ptr =
      _lookup<ffi.NativeFunction<_c_opus_packet_unpad>>('opus_packet_unpad');
  late final _dart_opus_packet_unpad _opus_packet_unpad =
      _opus_packet_unpad_ptr.asFunction<_dart_opus_packet_unpad>();

  /// Pads a given Opus multi-stream packet to a larger size (possibly changing the TOC sequence).
  /// @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the
  /// packet to pad.
  /// @param len <tt>opus_int32</tt>: The size of the packet.
  /// This must be at least 1.
  /// @param new_len <tt>opus_int32</tt>: The desired size of the packet after padding.
  /// This must be at least 1.
  /// @param nb_streams <tt>opus_int32</tt>: The number of streams (not channels) in the packet.
  /// This must be at least as large as len.
  /// @returns an error code
  /// @retval #OPUS_OK \a on success.
  /// @retval #OPUS_BAD_ARG \a len was less than 1.
  /// @retval #OPUS_INVALID_PACKET \a data did not contain a valid Opus packet.
  int opus_multistream_packet_pad(
    ffi.Pointer<ffi.Uint8> data,
    int len,
    int new_len,
    int nb_streams,
  ) {
    return _opus_multistream_packet_pad(
      data,
      len,
      new_len,
      nb_streams,
    );
  }

  late final _opus_multistream_packet_pad_ptr =
      _lookup<ffi.NativeFunction<_c_opus_multistream_packet_pad>>(
          'opus_multistream_packet_pad');
  late final _dart_opus_multistream_packet_pad _opus_multistream_packet_pad =
      _opus_multistream_packet_pad_ptr
          .asFunction<_dart_opus_multistream_packet_pad>();

  /// Remove all padding from a given Opus multi-stream packet and rewrite the TOC sequence to
  /// minimize space usage.
  /// @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the
  /// packet to strip.
  /// @param len <tt>opus_int32</tt>: The size of the packet.
  /// This must be at least 1.
  /// @param nb_streams <tt>opus_int32</tt>: The number of streams (not channels) in the packet.
  /// This must be at least 1.
  /// @returns The new size of the output packet on success, or an error code
  /// on failure.
  /// @retval #OPUS_BAD_ARG \a len was less than 1 or new_len was less than len.
  /// @retval #OPUS_INVALID_PACKET \a data did not contain a valid Opus packet.
  int opus_multistream_packet_unpad(
    ffi.Pointer<ffi.Uint8> data,
    int len,
    int nb_streams,
  ) {
    return _opus_multistream_packet_unpad(
      data,
      len,
      nb_streams,
    );
  }

  late final _opus_multistream_packet_unpad_ptr =
      _lookup<ffi.NativeFunction<_c_opus_multistream_packet_unpad>>(
          'opus_multistream_packet_unpad');
  late final _dart_opus_multistream_packet_unpad
      _opus_multistream_packet_unpad = _opus_multistream_packet_unpad_ptr
          .asFunction<_dart_opus_multistream_packet_unpad>();

  /// Gets the size of an OpusMSEncoder structure.
  /// @param streams <tt>int</tt>: The total number of streams to encode from the
  /// input.
  /// This must be no more than 255.
  /// @param coupled_streams <tt>int</tt>: Number of coupled (2 channel) streams
  /// to encode.
  /// This must be no larger than the total
  /// number of streams.
  /// Additionally, The total number of
  /// encoded channels (<code>streams +
  /// coupled_streams</code>) must be no
  /// more than 255.
  /// @returns The size in bytes on success, or a negative error code
  /// (see @ref opus_errorcodes) on error.
  int opus_multistream_encoder_get_size(
    int streams,
    int coupled_streams,
  ) {
    return _opus_multistream_encoder_get_size(
      streams,
      coupled_streams,
    );
  }

  late final _opus_multistream_encoder_get_size_ptr =
      _lookup<ffi.NativeFunction<_c_opus_multistream_encoder_get_size>>(
          'opus_multistream_encoder_get_size');
  late final _dart_opus_multistream_encoder_get_size
      _opus_multistream_encoder_get_size =
      _opus_multistream_encoder_get_size_ptr
          .asFunction<_dart_opus_multistream_encoder_get_size>();

  int opus_multistream_surround_encoder_get_size(
    int channels,
    int mapping_family,
  ) {
    return _opus_multistream_surround_encoder_get_size(
      channels,
      mapping_family,
    );
  }

  late final _opus_multistream_surround_encoder_get_size_ptr = _lookup<
          ffi.NativeFunction<_c_opus_multistream_surround_encoder_get_size>>(
      'opus_multistream_surround_encoder_get_size');
  late final _dart_opus_multistream_surround_encoder_get_size
      _opus_multistream_surround_encoder_get_size =
      _opus_multistream_surround_encoder_get_size_ptr
          .asFunction<_dart_opus_multistream_surround_encoder_get_size>();

  /// Allocates and initializes a multistream encoder state.
  /// Call opus_multistream_encoder_destroy() to release
  /// this object when finished.
  /// @param Fs <tt>opus_int32</tt>: Sampling rate of the input signal (in Hz).
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param channels <tt>int</tt>: Number of channels in the input signal.
  /// This must be at most 255.
  /// It may be greater than the number of
  /// coded channels (<code>streams +
  /// coupled_streams</code>).
  /// @param streams <tt>int</tt>: The total number of streams to encode from the
  /// input.
  /// This must be no more than the number of channels.
  /// @param coupled_streams <tt>int</tt>: Number of coupled (2 channel) streams
  /// to encode.
  /// This must be no larger than the total
  /// number of streams.
  /// Additionally, The total number of
  /// encoded channels (<code>streams +
  /// coupled_streams</code>) must be no
  /// more than the number of input channels.
  /// @param[in] mapping <code>const unsigned char[channels]</code>: Mapping from
  /// encoded channels to input channels, as described in
  /// @ref opus_multistream. As an extra constraint, the
  /// multistream encoder does not allow encoding coupled
  /// streams for which one channel is unused since this
  /// is never a good idea.
  /// @param application <tt>int</tt>: The target encoder application.
  /// This must be one of the following:
  /// <dl>
  /// <dt>#OPUS_APPLICATION_VOIP</dt>
  /// <dd>Process signal for improved speech intelligibility.</dd>
  /// <dt>#OPUS_APPLICATION_AUDIO</dt>
  /// <dd>Favor faithfulness to the original input.</dd>
  /// <dt>#OPUS_APPLICATION_RESTRICTED_LOWDELAY</dt>
  /// <dd>Configure the minimum possible coding delay by disabling certain modes
  /// of operation.</dd>
  /// </dl>
  /// @param[out] error <tt>int *</tt>: Returns #OPUS_OK on success, or an error
  /// code (see @ref opus_errorcodes) on
  /// failure.
  ffi.Pointer<OpusMSEncoder> opus_multistream_encoder_create(
    int Fs,
    int channels,
    int streams,
    int coupled_streams,
    ffi.Pointer<ffi.Uint8> mapping,
    int application,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _opus_multistream_encoder_create(
      Fs,
      channels,
      streams,
      coupled_streams,
      mapping,
      application,
      error,
    );
  }

  late final _opus_multistream_encoder_create_ptr =
      _lookup<ffi.NativeFunction<_c_opus_multistream_encoder_create>>(
          'opus_multistream_encoder_create');
  late final _dart_opus_multistream_encoder_create
      _opus_multistream_encoder_create = _opus_multistream_encoder_create_ptr
          .asFunction<_dart_opus_multistream_encoder_create>();

  ffi.Pointer<OpusMSEncoder> opus_multistream_surround_encoder_create(
    int Fs,
    int channels,
    int mapping_family,
    ffi.Pointer<ffi.Int32> streams,
    ffi.Pointer<ffi.Int32> coupled_streams,
    ffi.Pointer<ffi.Uint8> mapping,
    int application,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _opus_multistream_surround_encoder_create(
      Fs,
      channels,
      mapping_family,
      streams,
      coupled_streams,
      mapping,
      application,
      error,
    );
  }

  late final _opus_multistream_surround_encoder_create_ptr =
      _lookup<ffi.NativeFunction<_c_opus_multistream_surround_encoder_create>>(
          'opus_multistream_surround_encoder_create');
  late final _dart_opus_multistream_surround_encoder_create
      _opus_multistream_surround_encoder_create =
      _opus_multistream_surround_encoder_create_ptr
          .asFunction<_dart_opus_multistream_surround_encoder_create>();

  /// Initialize a previously allocated multistream encoder state.
  /// The memory pointed to by \a st must be at least the size returned by
  /// opus_multistream_encoder_get_size().
  /// This is intended for applications which use their own allocator instead of
  /// malloc.
  /// To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.
  /// @see opus_multistream_encoder_create
  /// @see opus_multistream_encoder_get_size
  /// @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state to initialize.
  /// @param Fs <tt>opus_int32</tt>: Sampling rate of the input signal (in Hz).
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param channels <tt>int</tt>: Number of channels in the input signal.
  /// This must be at most 255.
  /// It may be greater than the number of
  /// coded channels (<code>streams +
  /// coupled_streams</code>).
  /// @param streams <tt>int</tt>: The total number of streams to encode from the
  /// input.
  /// This must be no more than the number of channels.
  /// @param coupled_streams <tt>int</tt>: Number of coupled (2 channel) streams
  /// to encode.
  /// This must be no larger than the total
  /// number of streams.
  /// Additionally, The total number of
  /// encoded channels (<code>streams +
  /// coupled_streams</code>) must be no
  /// more than the number of input channels.
  /// @param[in] mapping <code>const unsigned char[channels]</code>: Mapping from
  /// encoded channels to input channels, as described in
  /// @ref opus_multistream. As an extra constraint, the
  /// multistream encoder does not allow encoding coupled
  /// streams for which one channel is unused since this
  /// is never a good idea.
  /// @param application <tt>int</tt>: The target encoder application.
  /// This must be one of the following:
  /// <dl>
  /// <dt>#OPUS_APPLICATION_VOIP</dt>
  /// <dd>Process signal for improved speech intelligibility.</dd>
  /// <dt>#OPUS_APPLICATION_AUDIO</dt>
  /// <dd>Favor faithfulness to the original input.</dd>
  /// <dt>#OPUS_APPLICATION_RESTRICTED_LOWDELAY</dt>
  /// <dd>Configure the minimum possible coding delay by disabling certain modes
  /// of operation.</dd>
  /// </dl>
  /// @returns #OPUS_OK on success, or an error code (see @ref opus_errorcodes)
  /// on failure.
  int opus_multistream_encoder_init(
    ffi.Pointer<OpusMSEncoder> st,
    int Fs,
    int channels,
    int streams,
    int coupled_streams,
    ffi.Pointer<ffi.Uint8> mapping,
    int application,
  ) {
    return _opus_multistream_encoder_init(
      st,
      Fs,
      channels,
      streams,
      coupled_streams,
      mapping,
      application,
    );
  }

  late final _opus_multistream_encoder_init_ptr =
      _lookup<ffi.NativeFunction<_c_opus_multistream_encoder_init>>(
          'opus_multistream_encoder_init');
  late final _dart_opus_multistream_encoder_init
      _opus_multistream_encoder_init = _opus_multistream_encoder_init_ptr
          .asFunction<_dart_opus_multistream_encoder_init>();

  int opus_multistream_surround_encoder_init(
    ffi.Pointer<OpusMSEncoder> st,
    int Fs,
    int channels,
    int mapping_family,
    ffi.Pointer<ffi.Int32> streams,
    ffi.Pointer<ffi.Int32> coupled_streams,
    ffi.Pointer<ffi.Uint8> mapping,
    int application,
  ) {
    return _opus_multistream_surround_encoder_init(
      st,
      Fs,
      channels,
      mapping_family,
      streams,
      coupled_streams,
      mapping,
      application,
    );
  }

  late final _opus_multistream_surround_encoder_init_ptr =
      _lookup<ffi.NativeFunction<_c_opus_multistream_surround_encoder_init>>(
          'opus_multistream_surround_encoder_init');
  late final _dart_opus_multistream_surround_encoder_init
      _opus_multistream_surround_encoder_init =
      _opus_multistream_surround_encoder_init_ptr
          .asFunction<_dart_opus_multistream_surround_encoder_init>();

  /// Encodes a multistream Opus frame.
  /// @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state.
  /// @param[in] pcm <tt>const opus_int16*</tt>: The input signal as interleaved
  /// samples.
  /// This must contain
  /// <code>frame_size*channels</code>
  /// samples.
  /// @param frame_size <tt>int</tt>: Number of samples per channel in the input
  /// signal.
  /// This must be an Opus frame size for the
  /// encoder's sampling rate.
  /// For example, at 48 kHz the permitted values
  /// are 120, 240, 480, 960, 1920, and 2880.
  /// Passing in a duration of less than 10 ms
  /// (480 samples at 48 kHz) will prevent the
  /// encoder from using the LPC or hybrid modes.
  /// @param[out] data <tt>unsigned char*</tt>: Output payload.
  /// This must contain storage for at
  /// least \a max_data_bytes.
  /// @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated
  /// memory for the output
  /// payload. This may be
  /// used to impose an upper limit on
  /// the instant bitrate, but should
  /// not be used as the only bitrate
  /// control. Use #OPUS_SET_BITRATE to
  /// control the bitrate.
  /// @returns The length of the encoded packet (in bytes) on success or a
  /// negative error code (see @ref opus_errorcodes) on failure.
  int opus_multistream_encode(
    ffi.Pointer<OpusMSEncoder> st,
    ffi.Pointer<ffi.Int16> pcm,
    int frame_size,
    ffi.Pointer<ffi.Uint8> data,
    int max_data_bytes,
  ) {
    return _opus_multistream_encode(
      st,
      pcm,
      frame_size,
      data,
      max_data_bytes,
    );
  }

  late final _opus_multistream_encode_ptr =
      _lookup<ffi.NativeFunction<_c_opus_multistream_encode>>(
          'opus_multistream_encode');
  late final _dart_opus_multistream_encode _opus_multistream_encode =
      _opus_multistream_encode_ptr.asFunction<_dart_opus_multistream_encode>();

  /// Encodes a multistream Opus frame from floating point input.
  /// @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state.
  /// @param[in] pcm <tt>const float*</tt>: The input signal as interleaved
  /// samples with a normal range of
  /// +/-1.0.
  /// Samples with a range beyond +/-1.0
  /// are supported but will be clipped by
  /// decoders using the integer API and
  /// should only be used if it is known
  /// that the far end supports extended
  /// dynamic range.
  /// This must contain
  /// <code>frame_size*channels</code>
  /// samples.
  /// @param frame_size <tt>int</tt>: Number of samples per channel in the input
  /// signal.
  /// This must be an Opus frame size for the
  /// encoder's sampling rate.
  /// For example, at 48 kHz the permitted values
  /// are 120, 240, 480, 960, 1920, and 2880.
  /// Passing in a duration of less than 10 ms
  /// (480 samples at 48 kHz) will prevent the
  /// encoder from using the LPC or hybrid modes.
  /// @param[out] data <tt>unsigned char*</tt>: Output payload.
  /// This must contain storage for at
  /// least \a max_data_bytes.
  /// @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated
  /// memory for the output
  /// payload. This may be
  /// used to impose an upper limit on
  /// the instant bitrate, but should
  /// not be used as the only bitrate
  /// control. Use #OPUS_SET_BITRATE to
  /// control the bitrate.
  /// @returns The length of the encoded packet (in bytes) on success or a
  /// negative error code (see @ref opus_errorcodes) on failure.
  int opus_multistream_encode_float(
    ffi.Pointer<OpusMSEncoder> st,
    ffi.Pointer<ffi.Float> pcm,
    int frame_size,
    ffi.Pointer<ffi.Uint8> data,
    int max_data_bytes,
  ) {
    return _opus_multistream_encode_float(
      st,
      pcm,
      frame_size,
      data,
      max_data_bytes,
    );
  }

  late final _opus_multistream_encode_float_ptr =
      _lookup<ffi.NativeFunction<_c_opus_multistream_encode_float>>(
          'opus_multistream_encode_float');
  late final _dart_opus_multistream_encode_float
      _opus_multistream_encode_float = _opus_multistream_encode_float_ptr
          .asFunction<_dart_opus_multistream_encode_float>();

  /// Frees an <code>OpusMSEncoder</code> allocated by
  /// opus_multistream_encoder_create().
  /// @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state to be freed.
  void opus_multistream_encoder_destroy(
    ffi.Pointer<OpusMSEncoder> st,
  ) {
    return _opus_multistream_encoder_destroy(
      st,
    );
  }

  late final _opus_multistream_encoder_destroy_ptr =
      _lookup<ffi.NativeFunction<_c_opus_multistream_encoder_destroy>>(
          'opus_multistream_encoder_destroy');
  late final _dart_opus_multistream_encoder_destroy
      _opus_multistream_encoder_destroy = _opus_multistream_encoder_destroy_ptr
          .asFunction<_dart_opus_multistream_encoder_destroy>();

  /// Perform a CTL function on a multistream Opus encoder.
  ///
  /// Generally the request and subsequent arguments are generated by a
  /// convenience macro.
  /// @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state.
  /// @param request This and all remaining parameters should be replaced by one
  /// of the convenience macros in @ref opus_genericctls,
  /// @ref opus_encoderctls, or @ref opus_multistream_ctls.
  /// @see opus_genericctls
  /// @see opus_encoderctls
  /// @see opus_multistream_ctls
  int opus_multistream_encoder_ctl(
    ffi.Pointer<OpusMSEncoder> st,
    int request,
  ) {
    return _opus_multistream_encoder_ctl(
      st,
      request,
    );
  }

  late final _opus_multistream_encoder_ctl_ptr =
      _lookup<ffi.NativeFunction<_c_opus_multistream_encoder_ctl>>(
          'opus_multistream_encoder_ctl');
  late final _dart_opus_multistream_encoder_ctl _opus_multistream_encoder_ctl =
      _opus_multistream_encoder_ctl_ptr
          .asFunction<_dart_opus_multistream_encoder_ctl>();

  /// Gets the size of an <code>OpusMSDecoder</code> structure.
  /// @param streams <tt>int</tt>: The total number of streams coded in the
  /// input.
  /// This must be no more than 255.
  /// @param coupled_streams <tt>int</tt>: Number streams to decode as coupled
  /// (2 channel) streams.
  /// This must be no larger than the total
  /// number of streams.
  /// Additionally, The total number of
  /// coded channels (<code>streams +
  /// coupled_streams</code>) must be no
  /// more than 255.
  /// @returns The size in bytes on success, or a negative error code
  /// (see @ref opus_errorcodes) on error.
  int opus_multistream_decoder_get_size(
    int streams,
    int coupled_streams,
  ) {
    return _opus_multistream_decoder_get_size(
      streams,
      coupled_streams,
    );
  }

  late final _opus_multistream_decoder_get_size_ptr =
      _lookup<ffi.NativeFunction<_c_opus_multistream_decoder_get_size>>(
          'opus_multistream_decoder_get_size');
  late final _dart_opus_multistream_decoder_get_size
      _opus_multistream_decoder_get_size =
      _opus_multistream_decoder_get_size_ptr
          .asFunction<_dart_opus_multistream_decoder_get_size>();

  /// Allocates and initializes a multistream decoder state.
  /// Call opus_multistream_decoder_destroy() to release
  /// this object when finished.
  /// @param Fs <tt>opus_int32</tt>: Sampling rate to decode at (in Hz).
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param channels <tt>int</tt>: Number of channels to output.
  /// This must be at most 255.
  /// It may be different from the number of coded
  /// channels (<code>streams +
  /// coupled_streams</code>).
  /// @param streams <tt>int</tt>: The total number of streams coded in the
  /// input.
  /// This must be no more than 255.
  /// @param coupled_streams <tt>int</tt>: Number of streams to decode as coupled
  /// (2 channel) streams.
  /// This must be no larger than the total
  /// number of streams.
  /// Additionally, The total number of
  /// coded channels (<code>streams +
  /// coupled_streams</code>) must be no
  /// more than 255.
  /// @param[in] mapping <code>const unsigned char[channels]</code>: Mapping from
  /// coded channels to output channels, as described in
  /// @ref opus_multistream.
  /// @param[out] error <tt>int *</tt>: Returns #OPUS_OK on success, or an error
  /// code (see @ref opus_errorcodes) on
  /// failure.
  ffi.Pointer<OpusMSDecoder> opus_multistream_decoder_create(
    int Fs,
    int channels,
    int streams,
    int coupled_streams,
    ffi.Pointer<ffi.Uint8> mapping,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _opus_multistream_decoder_create(
      Fs,
      channels,
      streams,
      coupled_streams,
      mapping,
      error,
    );
  }

  late final _opus_multistream_decoder_create_ptr =
      _lookup<ffi.NativeFunction<_c_opus_multistream_decoder_create>>(
          'opus_multistream_decoder_create');
  late final _dart_opus_multistream_decoder_create
      _opus_multistream_decoder_create = _opus_multistream_decoder_create_ptr
          .asFunction<_dart_opus_multistream_decoder_create>();

  /// Intialize a previously allocated decoder state object.
  /// The memory pointed to by \a st must be at least the size returned by
  /// opus_multistream_encoder_get_size().
  /// This is intended for applications which use their own allocator instead of
  /// malloc.
  /// To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.
  /// @see opus_multistream_decoder_create
  /// @see opus_multistream_deocder_get_size
  /// @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state to initialize.
  /// @param Fs <tt>opus_int32</tt>: Sampling rate to decode at (in Hz).
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param channels <tt>int</tt>: Number of channels to output.
  /// This must be at most 255.
  /// It may be different from the number of coded
  /// channels (<code>streams +
  /// coupled_streams</code>).
  /// @param streams <tt>int</tt>: The total number of streams coded in the
  /// input.
  /// This must be no more than 255.
  /// @param coupled_streams <tt>int</tt>: Number of streams to decode as coupled
  /// (2 channel) streams.
  /// This must be no larger than the total
  /// number of streams.
  /// Additionally, The total number of
  /// coded channels (<code>streams +
  /// coupled_streams</code>) must be no
  /// more than 255.
  /// @param[in] mapping <code>const unsigned char[channels]</code>: Mapping from
  /// coded channels to output channels, as described in
  /// @ref opus_multistream.
  /// @returns #OPUS_OK on success, or an error code (see @ref opus_errorcodes)
  /// on failure.
  int opus_multistream_decoder_init(
    ffi.Pointer<OpusMSDecoder> st,
    int Fs,
    int channels,
    int streams,
    int coupled_streams,
    ffi.Pointer<ffi.Uint8> mapping,
  ) {
    return _opus_multistream_decoder_init(
      st,
      Fs,
      channels,
      streams,
      coupled_streams,
      mapping,
    );
  }

  late final _opus_multistream_decoder_init_ptr =
      _lookup<ffi.NativeFunction<_c_opus_multistream_decoder_init>>(
          'opus_multistream_decoder_init');
  late final _dart_opus_multistream_decoder_init
      _opus_multistream_decoder_init = _opus_multistream_decoder_init_ptr
          .asFunction<_dart_opus_multistream_decoder_init>();

  /// Decode a multistream Opus packet.
  /// @param st <tt>OpusMSDecoder*</tt>: Multistream decoder state.
  /// @param[in] data <tt>const unsigned char*</tt>: Input payload.
  /// Use a <code>NULL</code>
  /// pointer to indicate packet
  /// loss.
  /// @param len <tt>opus_int32</tt>: Number of bytes in payload.
  /// @param[out] pcm <tt>opus_int16*</tt>: Output signal, with interleaved
  /// samples.
  /// This must contain room for
  /// <code>frame_size*channels</code>
  /// samples.
  /// @param frame_size <tt>int</tt>: The number of samples per channel of
  /// available space in \a pcm.
  /// If this is less than the maximum packet duration
  /// (120 ms; 5760 for 48kHz), this function will not be capable
  /// of decoding some packets. In the case of PLC (data==NULL)
  /// or FEC (decode_fec=1), then frame_size needs to be exactly
  /// the duration of audio that is missing, otherwise the
  /// decoder will not be in the optimal state to decode the
  /// next incoming packet. For the PLC and FEC cases, frame_size
  /// <b>must</b> be a multiple of 2.5 ms.
  /// @param decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band
  /// forward error correction data be decoded.
  /// If no such data is available, the frame is
  /// decoded as if it were lost.
  /// @returns Number of samples decoded on success or a negative error code
  /// (see @ref opus_errorcodes) on failure.
  int opus_multistream_decode(
    ffi.Pointer<OpusMSDecoder> st,
    ffi.Pointer<ffi.Uint8> data,
    int len,
    ffi.Pointer<ffi.Int16> pcm,
    int frame_size,
    int decode_fec,
  ) {
    return _opus_multistream_decode(
      st,
      data,
      len,
      pcm,
      frame_size,
      decode_fec,
    );
  }

  late final _opus_multistream_decode_ptr =
      _lookup<ffi.NativeFunction<_c_opus_multistream_decode>>(
          'opus_multistream_decode');
  late final _dart_opus_multistream_decode _opus_multistream_decode =
      _opus_multistream_decode_ptr.asFunction<_dart_opus_multistream_decode>();

  /// Decode a multistream Opus packet with floating point output.
  /// @param st <tt>OpusMSDecoder*</tt>: Multistream decoder state.
  /// @param[in] data <tt>const unsigned char*</tt>: Input payload.
  /// Use a <code>NULL</code>
  /// pointer to indicate packet
  /// loss.
  /// @param len <tt>opus_int32</tt>: Number of bytes in payload.
  /// @param[out] pcm <tt>opus_int16*</tt>: Output signal, with interleaved
  /// samples.
  /// This must contain room for
  /// <code>frame_size*channels</code>
  /// samples.
  /// @param frame_size <tt>int</tt>: The number of samples per channel of
  /// available space in \a pcm.
  /// If this is less than the maximum packet duration
  /// (120 ms; 5760 for 48kHz), this function will not be capable
  /// of decoding some packets. In the case of PLC (data==NULL)
  /// or FEC (decode_fec=1), then frame_size needs to be exactly
  /// the duration of audio that is missing, otherwise the
  /// decoder will not be in the optimal state to decode the
  /// next incoming packet. For the PLC and FEC cases, frame_size
  /// <b>must</b> be a multiple of 2.5 ms.
  /// @param decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band
  /// forward error correction data be decoded.
  /// If no such data is available, the frame is
  /// decoded as if it were lost.
  /// @returns Number of samples decoded on success or a negative error code
  /// (see @ref opus_errorcodes) on failure.
  int opus_multistream_decode_float(
    ffi.Pointer<OpusMSDecoder> st,
    ffi.Pointer<ffi.Uint8> data,
    int len,
    ffi.Pointer<ffi.Float> pcm,
    int frame_size,
    int decode_fec,
  ) {
    return _opus_multistream_decode_float(
      st,
      data,
      len,
      pcm,
      frame_size,
      decode_fec,
    );
  }

  late final _opus_multistream_decode_float_ptr =
      _lookup<ffi.NativeFunction<_c_opus_multistream_decode_float>>(
          'opus_multistream_decode_float');
  late final _dart_opus_multistream_decode_float
      _opus_multistream_decode_float = _opus_multistream_decode_float_ptr
          .asFunction<_dart_opus_multistream_decode_float>();

  /// Perform a CTL function on a multistream Opus decoder.
  ///
  /// Generally the request and subsequent arguments are generated by a
  /// convenience macro.
  /// @param st <tt>OpusMSDecoder*</tt>: Multistream decoder state.
  /// @param request This and all remaining parameters should be replaced by one
  /// of the convenience macros in @ref opus_genericctls,
  /// @ref opus_decoderctls, or @ref opus_multistream_ctls.
  /// @see opus_genericctls
  /// @see opus_decoderctls
  /// @see opus_multistream_ctls
  int opus_multistream_decoder_ctl(
    ffi.Pointer<OpusMSDecoder> st,
    int request,
  ) {
    return _opus_multistream_decoder_ctl(
      st,
      request,
    );
  }

  late final _opus_multistream_decoder_ctl_ptr =
      _lookup<ffi.NativeFunction<_c_opus_multistream_decoder_ctl>>(
          'opus_multistream_decoder_ctl');
  late final _dart_opus_multistream_decoder_ctl _opus_multistream_decoder_ctl =
      _opus_multistream_decoder_ctl_ptr
          .asFunction<_dart_opus_multistream_decoder_ctl>();

  /// Frees an <code>OpusMSDecoder</code> allocated by
  /// opus_multistream_decoder_create().
  /// @param st <tt>OpusMSDecoder</tt>: Multistream decoder state to be freed.
  void opus_multistream_decoder_destroy(
    ffi.Pointer<OpusMSDecoder> st,
  ) {
    return _opus_multistream_decoder_destroy(
      st,
    );
  }

  late final _opus_multistream_decoder_destroy_ptr =
      _lookup<ffi.NativeFunction<_c_opus_multistream_decoder_destroy>>(
          'opus_multistream_decoder_destroy');
  late final _dart_opus_multistream_decoder_destroy
      _opus_multistream_decoder_destroy = _opus_multistream_decoder_destroy_ptr
          .asFunction<_dart_opus_multistream_decoder_destroy>();

  /// Gets the size of an OpusProjectionEncoder structure.
  /// @param channels <tt>int</tt>: The total number of input channels to encode.
  /// This must be no more than 255.
  /// @param mapping_family <tt>int</tt>: The mapping family to use for selecting
  /// the appropriate projection.
  /// @returns The size in bytes on success, or a negative error code
  /// (see @ref opus_errorcodes) on error.
  int opus_projection_ambisonics_encoder_get_size(
    int channels,
    int mapping_family,
  ) {
    return _opus_projection_ambisonics_encoder_get_size(
      channels,
      mapping_family,
    );
  }

  late final _opus_projection_ambisonics_encoder_get_size_ptr = _lookup<
          ffi.NativeFunction<_c_opus_projection_ambisonics_encoder_get_size>>(
      'opus_projection_ambisonics_encoder_get_size');
  late final _dart_opus_projection_ambisonics_encoder_get_size
      _opus_projection_ambisonics_encoder_get_size =
      _opus_projection_ambisonics_encoder_get_size_ptr
          .asFunction<_dart_opus_projection_ambisonics_encoder_get_size>();

  /// Allocates and initializes a projection encoder state.
  /// Call opus_projection_encoder_destroy() to release
  /// this object when finished.
  /// @param Fs <tt>opus_int32</tt>: Sampling rate of the input signal (in Hz).
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param channels <tt>int</tt>: Number of channels in the input signal.
  /// This must be at most 255.
  /// It may be greater than the number of
  /// coded channels (<code>streams +
  /// coupled_streams</code>).
  /// @param mapping_family <tt>int</tt>: The mapping family to use for selecting
  /// the appropriate projection.
  /// @param[out] streams <tt>int *</tt>: The total number of streams that will
  /// be encoded from the input.
  /// @param[out] coupled_streams <tt>int *</tt>: Number of coupled (2 channel)
  /// streams that will be encoded from the input.
  /// @param application <tt>int</tt>: The target encoder application.
  /// This must be one of the following:
  /// <dl>
  /// <dt>#OPUS_APPLICATION_VOIP</dt>
  /// <dd>Process signal for improved speech intelligibility.</dd>
  /// <dt>#OPUS_APPLICATION_AUDIO</dt>
  /// <dd>Favor faithfulness to the original input.</dd>
  /// <dt>#OPUS_APPLICATION_RESTRICTED_LOWDELAY</dt>
  /// <dd>Configure the minimum possible coding delay by disabling certain modes
  /// of operation.</dd>
  /// </dl>
  /// @param[out] error <tt>int *</tt>: Returns #OPUS_OK on success, or an error
  /// code (see @ref opus_errorcodes) on
  /// failure.
  ffi.Pointer<OpusProjectionEncoder> opus_projection_ambisonics_encoder_create(
    int Fs,
    int channels,
    int mapping_family,
    ffi.Pointer<ffi.Int32> streams,
    ffi.Pointer<ffi.Int32> coupled_streams,
    int application,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _opus_projection_ambisonics_encoder_create(
      Fs,
      channels,
      mapping_family,
      streams,
      coupled_streams,
      application,
      error,
    );
  }

  late final _opus_projection_ambisonics_encoder_create_ptr =
      _lookup<ffi.NativeFunction<_c_opus_projection_ambisonics_encoder_create>>(
          'opus_projection_ambisonics_encoder_create');
  late final _dart_opus_projection_ambisonics_encoder_create
      _opus_projection_ambisonics_encoder_create =
      _opus_projection_ambisonics_encoder_create_ptr
          .asFunction<_dart_opus_projection_ambisonics_encoder_create>();

  /// Initialize a previously allocated projection encoder state.
  /// The memory pointed to by \a st must be at least the size returned by
  /// opus_projection_ambisonics_encoder_get_size().
  /// This is intended for applications which use their own allocator instead of
  /// malloc.
  /// To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.
  /// @see opus_projection_ambisonics_encoder_create
  /// @see opus_projection_ambisonics_encoder_get_size
  /// @param st <tt>OpusProjectionEncoder*</tt>: Projection encoder state to initialize.
  /// @param Fs <tt>opus_int32</tt>: Sampling rate of the input signal (in Hz).
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param channels <tt>int</tt>: Number of channels in the input signal.
  /// This must be at most 255.
  /// It may be greater than the number of
  /// coded channels (<code>streams +
  /// coupled_streams</code>).
  /// @param streams <tt>int</tt>: The total number of streams to encode from the
  /// input.
  /// This must be no more than the number of channels.
  /// @param coupled_streams <tt>int</tt>: Number of coupled (2 channel) streams
  /// to encode.
  /// This must be no larger than the total
  /// number of streams.
  /// Additionally, The total number of
  /// encoded channels (<code>streams +
  /// coupled_streams</code>) must be no
  /// more than the number of input channels.
  /// @param application <tt>int</tt>: The target encoder application.
  /// This must be one of the following:
  /// <dl>
  /// <dt>#OPUS_APPLICATION_VOIP</dt>
  /// <dd>Process signal for improved speech intelligibility.</dd>
  /// <dt>#OPUS_APPLICATION_AUDIO</dt>
  /// <dd>Favor faithfulness to the original input.</dd>
  /// <dt>#OPUS_APPLICATION_RESTRICTED_LOWDELAY</dt>
  /// <dd>Configure the minimum possible coding delay by disabling certain modes
  /// of operation.</dd>
  /// </dl>
  /// @returns #OPUS_OK on success, or an error code (see @ref opus_errorcodes)
  /// on failure.
  int opus_projection_ambisonics_encoder_init(
    ffi.Pointer<OpusProjectionEncoder> st,
    int Fs,
    int channels,
    int mapping_family,
    ffi.Pointer<ffi.Int32> streams,
    ffi.Pointer<ffi.Int32> coupled_streams,
    int application,
  ) {
    return _opus_projection_ambisonics_encoder_init(
      st,
      Fs,
      channels,
      mapping_family,
      streams,
      coupled_streams,
      application,
    );
  }

  late final _opus_projection_ambisonics_encoder_init_ptr =
      _lookup<ffi.NativeFunction<_c_opus_projection_ambisonics_encoder_init>>(
          'opus_projection_ambisonics_encoder_init');
  late final _dart_opus_projection_ambisonics_encoder_init
      _opus_projection_ambisonics_encoder_init =
      _opus_projection_ambisonics_encoder_init_ptr
          .asFunction<_dart_opus_projection_ambisonics_encoder_init>();

  /// Encodes a projection Opus frame.
  /// @param st <tt>OpusProjectionEncoder*</tt>: Projection encoder state.
  /// @param[in] pcm <tt>const opus_int16*</tt>: The input signal as interleaved
  /// samples.
  /// This must contain
  /// <code>frame_size*channels</code>
  /// samples.
  /// @param frame_size <tt>int</tt>: Number of samples per channel in the input
  /// signal.
  /// This must be an Opus frame size for the
  /// encoder's sampling rate.
  /// For example, at 48 kHz the permitted values
  /// are 120, 240, 480, 960, 1920, and 2880.
  /// Passing in a duration of less than 10 ms
  /// (480 samples at 48 kHz) will prevent the
  /// encoder from using the LPC or hybrid modes.
  /// @param[out] data <tt>unsigned char*</tt>: Output payload.
  /// This must contain storage for at
  /// least \a max_data_bytes.
  /// @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated
  /// memory for the output
  /// payload. This may be
  /// used to impose an upper limit on
  /// the instant bitrate, but should
  /// not be used as the only bitrate
  /// control. Use #OPUS_SET_BITRATE to
  /// control the bitrate.
  /// @returns The length of the encoded packet (in bytes) on success or a
  /// negative error code (see @ref opus_errorcodes) on failure.
  int opus_projection_encode(
    ffi.Pointer<OpusProjectionEncoder> st,
    ffi.Pointer<ffi.Int16> pcm,
    int frame_size,
    ffi.Pointer<ffi.Uint8> data,
    int max_data_bytes,
  ) {
    return _opus_projection_encode(
      st,
      pcm,
      frame_size,
      data,
      max_data_bytes,
    );
  }

  late final _opus_projection_encode_ptr =
      _lookup<ffi.NativeFunction<_c_opus_projection_encode>>(
          'opus_projection_encode');
  late final _dart_opus_projection_encode _opus_projection_encode =
      _opus_projection_encode_ptr.asFunction<_dart_opus_projection_encode>();

  /// Encodes a projection Opus frame from floating point input.
  /// @param st <tt>OpusProjectionEncoder*</tt>: Projection encoder state.
  /// @param[in] pcm <tt>const float*</tt>: The input signal as interleaved
  /// samples with a normal range of
  /// +/-1.0.
  /// Samples with a range beyond +/-1.0
  /// are supported but will be clipped by
  /// decoders using the integer API and
  /// should only be used if it is known
  /// that the far end supports extended
  /// dynamic range.
  /// This must contain
  /// <code>frame_size*channels</code>
  /// samples.
  /// @param frame_size <tt>int</tt>: Number of samples per channel in the input
  /// signal.
  /// This must be an Opus frame size for the
  /// encoder's sampling rate.
  /// For example, at 48 kHz the permitted values
  /// are 120, 240, 480, 960, 1920, and 2880.
  /// Passing in a duration of less than 10 ms
  /// (480 samples at 48 kHz) will prevent the
  /// encoder from using the LPC or hybrid modes.
  /// @param[out] data <tt>unsigned char*</tt>: Output payload.
  /// This must contain storage for at
  /// least \a max_data_bytes.
  /// @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated
  /// memory for the output
  /// payload. This may be
  /// used to impose an upper limit on
  /// the instant bitrate, but should
  /// not be used as the only bitrate
  /// control. Use #OPUS_SET_BITRATE to
  /// control the bitrate.
  /// @returns The length of the encoded packet (in bytes) on success or a
  /// negative error code (see @ref opus_errorcodes) on failure.
  int opus_projection_encode_float(
    ffi.Pointer<OpusProjectionEncoder> st,
    ffi.Pointer<ffi.Float> pcm,
    int frame_size,
    ffi.Pointer<ffi.Uint8> data,
    int max_data_bytes,
  ) {
    return _opus_projection_encode_float(
      st,
      pcm,
      frame_size,
      data,
      max_data_bytes,
    );
  }

  late final _opus_projection_encode_float_ptr =
      _lookup<ffi.NativeFunction<_c_opus_projection_encode_float>>(
          'opus_projection_encode_float');
  late final _dart_opus_projection_encode_float _opus_projection_encode_float =
      _opus_projection_encode_float_ptr
          .asFunction<_dart_opus_projection_encode_float>();

  /// Frees an <code>OpusProjectionEncoder</code> allocated by
  /// opus_projection_ambisonics_encoder_create().
  /// @param st <tt>OpusProjectionEncoder*</tt>: Projection encoder state to be freed.
  void opus_projection_encoder_destroy(
    ffi.Pointer<OpusProjectionEncoder> st,
  ) {
    return _opus_projection_encoder_destroy(
      st,
    );
  }

  late final _opus_projection_encoder_destroy_ptr =
      _lookup<ffi.NativeFunction<_c_opus_projection_encoder_destroy>>(
          'opus_projection_encoder_destroy');
  late final _dart_opus_projection_encoder_destroy
      _opus_projection_encoder_destroy = _opus_projection_encoder_destroy_ptr
          .asFunction<_dart_opus_projection_encoder_destroy>();

  /// Perform a CTL function on a projection Opus encoder.
  ///
  /// Generally the request and subsequent arguments are generated by a
  /// convenience macro.
  /// @param st <tt>OpusProjectionEncoder*</tt>: Projection encoder state.
  /// @param request This and all remaining parameters should be replaced by one
  /// of the convenience macros in @ref opus_genericctls,
  /// @ref opus_encoderctls, @ref opus_multistream_ctls, or
  /// @ref opus_projection_ctls
  /// @see opus_genericctls
  /// @see opus_encoderctls
  /// @see opus_multistream_ctls
  /// @see opus_projection_ctls
  int opus_projection_encoder_ctl(
    ffi.Pointer<OpusProjectionEncoder> st,
    int request,
  ) {
    return _opus_projection_encoder_ctl(
      st,
      request,
    );
  }

  late final _opus_projection_encoder_ctl_ptr =
      _lookup<ffi.NativeFunction<_c_opus_projection_encoder_ctl>>(
          'opus_projection_encoder_ctl');
  late final _dart_opus_projection_encoder_ctl _opus_projection_encoder_ctl =
      _opus_projection_encoder_ctl_ptr
          .asFunction<_dart_opus_projection_encoder_ctl>();

  /// Gets the size of an <code>OpusProjectionDecoder</code> structure.
  /// @param channels <tt>int</tt>: The total number of output channels.
  /// This must be no more than 255.
  /// @param streams <tt>int</tt>: The total number of streams coded in the
  /// input.
  /// This must be no more than 255.
  /// @param coupled_streams <tt>int</tt>: Number streams to decode as coupled
  /// (2 channel) streams.
  /// This must be no larger than the total
  /// number of streams.
  /// Additionally, The total number of
  /// coded channels (<code>streams +
  /// coupled_streams</code>) must be no
  /// more than 255.
  /// @returns The size in bytes on success, or a negative error code
  /// (see @ref opus_errorcodes) on error.
  int opus_projection_decoder_get_size(
    int channels,
    int streams,
    int coupled_streams,
  ) {
    return _opus_projection_decoder_get_size(
      channels,
      streams,
      coupled_streams,
    );
  }

  late final _opus_projection_decoder_get_size_ptr =
      _lookup<ffi.NativeFunction<_c_opus_projection_decoder_get_size>>(
          'opus_projection_decoder_get_size');
  late final _dart_opus_projection_decoder_get_size
      _opus_projection_decoder_get_size = _opus_projection_decoder_get_size_ptr
          .asFunction<_dart_opus_projection_decoder_get_size>();

  /// Allocates and initializes a projection decoder state.
  /// Call opus_projection_decoder_destroy() to release
  /// this object when finished.
  /// @param Fs <tt>opus_int32</tt>: Sampling rate to decode at (in Hz).
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param channels <tt>int</tt>: Number of channels to output.
  /// This must be at most 255.
  /// It may be different from the number of coded
  /// channels (<code>streams +
  /// coupled_streams</code>).
  /// @param streams <tt>int</tt>: The total number of streams coded in the
  /// input.
  /// This must be no more than 255.
  /// @param coupled_streams <tt>int</tt>: Number of streams to decode as coupled
  /// (2 channel) streams.
  /// This must be no larger than the total
  /// number of streams.
  /// Additionally, The total number of
  /// coded channels (<code>streams +
  /// coupled_streams</code>) must be no
  /// more than 255.
  /// @param[in] demixing_matrix <tt>const unsigned char[demixing_matrix_size]</tt>: Demixing matrix
  /// that mapping from coded channels to output channels,
  /// as described in @ref opus_projection and
  /// @ref opus_projection_ctls.
  /// @param demixing_matrix_size <tt>opus_int32</tt>: The size in bytes of the
  /// demixing matrix, as
  /// described in @ref
  /// opus_projection_ctls.
  /// @param[out] error <tt>int *</tt>: Returns #OPUS_OK on success, or an error
  /// code (see @ref opus_errorcodes) on
  /// failure.
  ffi.Pointer<OpusProjectionDecoder> opus_projection_decoder_create(
    int Fs,
    int channels,
    int streams,
    int coupled_streams,
    ffi.Pointer<ffi.Uint8> demixing_matrix,
    int demixing_matrix_size,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _opus_projection_decoder_create(
      Fs,
      channels,
      streams,
      coupled_streams,
      demixing_matrix,
      demixing_matrix_size,
      error,
    );
  }

  late final _opus_projection_decoder_create_ptr =
      _lookup<ffi.NativeFunction<_c_opus_projection_decoder_create>>(
          'opus_projection_decoder_create');
  late final _dart_opus_projection_decoder_create
      _opus_projection_decoder_create = _opus_projection_decoder_create_ptr
          .asFunction<_dart_opus_projection_decoder_create>();

  /// Intialize a previously allocated projection decoder state object.
  /// The memory pointed to by \a st must be at least the size returned by
  /// opus_projection_decoder_get_size().
  /// This is intended for applications which use their own allocator instead of
  /// malloc.
  /// To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.
  /// @see opus_projection_decoder_create
  /// @see opus_projection_deocder_get_size
  /// @param st <tt>OpusProjectionDecoder*</tt>: Projection encoder state to initialize.
  /// @param Fs <tt>opus_int32</tt>: Sampling rate to decode at (in Hz).
  /// This must be one of 8000, 12000, 16000,
  /// 24000, or 48000.
  /// @param channels <tt>int</tt>: Number of channels to output.
  /// This must be at most 255.
  /// It may be different from the number of coded
  /// channels (<code>streams +
  /// coupled_streams</code>).
  /// @param streams <tt>int</tt>: The total number of streams coded in the
  /// input.
  /// This must be no more than 255.
  /// @param coupled_streams <tt>int</tt>: Number of streams to decode as coupled
  /// (2 channel) streams.
  /// This must be no larger than the total
  /// number of streams.
  /// Additionally, The total number of
  /// coded channels (<code>streams +
  /// coupled_streams</code>) must be no
  /// more than 255.
  /// @param[in] demixing_matrix <tt>const unsigned char[demixing_matrix_size]</tt>: Demixing matrix
  /// that mapping from coded channels to output channels,
  /// as described in @ref opus_projection and
  /// @ref opus_projection_ctls.
  /// @param demixing_matrix_size <tt>opus_int32</tt>: The size in bytes of the
  /// demixing matrix, as
  /// described in @ref
  /// opus_projection_ctls.
  /// @returns #OPUS_OK on success, or an error code (see @ref opus_errorcodes)
  /// on failure.
  int opus_projection_decoder_init(
    ffi.Pointer<OpusProjectionDecoder> st,
    int Fs,
    int channels,
    int streams,
    int coupled_streams,
    ffi.Pointer<ffi.Uint8> demixing_matrix,
    int demixing_matrix_size,
  ) {
    return _opus_projection_decoder_init(
      st,
      Fs,
      channels,
      streams,
      coupled_streams,
      demixing_matrix,
      demixing_matrix_size,
    );
  }

  late final _opus_projection_decoder_init_ptr =
      _lookup<ffi.NativeFunction<_c_opus_projection_decoder_init>>(
          'opus_projection_decoder_init');
  late final _dart_opus_projection_decoder_init _opus_projection_decoder_init =
      _opus_projection_decoder_init_ptr
          .asFunction<_dart_opus_projection_decoder_init>();

  /// Decode a projection Opus packet.
  /// @param st <tt>OpusProjectionDecoder*</tt>: Projection decoder state.
  /// @param[in] data <tt>const unsigned char*</tt>: Input payload.
  /// Use a <code>NULL</code>
  /// pointer to indicate packet
  /// loss.
  /// @param len <tt>opus_int32</tt>: Number of bytes in payload.
  /// @param[out] pcm <tt>opus_int16*</tt>: Output signal, with interleaved
  /// samples.
  /// This must contain room for
  /// <code>frame_size*channels</code>
  /// samples.
  /// @param frame_size <tt>int</tt>: The number of samples per channel of
  /// available space in \a pcm.
  /// If this is less than the maximum packet duration
  /// (120 ms; 5760 for 48kHz), this function will not be capable
  /// of decoding some packets. In the case of PLC (data==NULL)
  /// or FEC (decode_fec=1), then frame_size needs to be exactly
  /// the duration of audio that is missing, otherwise the
  /// decoder will not be in the optimal state to decode the
  /// next incoming packet. For the PLC and FEC cases, frame_size
  /// <b>must</b> be a multiple of 2.5 ms.
  /// @param decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band
  /// forward error correction data be decoded.
  /// If no such data is available, the frame is
  /// decoded as if it were lost.
  /// @returns Number of samples decoded on success or a negative error code
  /// (see @ref opus_errorcodes) on failure.
  int opus_projection_decode(
    ffi.Pointer<OpusProjectionDecoder> st,
    ffi.Pointer<ffi.Uint8> data,
    int len,
    ffi.Pointer<ffi.Int16> pcm,
    int frame_size,
    int decode_fec,
  ) {
    return _opus_projection_decode(
      st,
      data,
      len,
      pcm,
      frame_size,
      decode_fec,
    );
  }

  late final _opus_projection_decode_ptr =
      _lookup<ffi.NativeFunction<_c_opus_projection_decode>>(
          'opus_projection_decode');
  late final _dart_opus_projection_decode _opus_projection_decode =
      _opus_projection_decode_ptr.asFunction<_dart_opus_projection_decode>();

  /// Decode a projection Opus packet with floating point output.
  /// @param st <tt>OpusProjectionDecoder*</tt>: Projection decoder state.
  /// @param[in] data <tt>const unsigned char*</tt>: Input payload.
  /// Use a <code>NULL</code>
  /// pointer to indicate packet
  /// loss.
  /// @param len <tt>opus_int32</tt>: Number of bytes in payload.
  /// @param[out] pcm <tt>opus_int16*</tt>: Output signal, with interleaved
  /// samples.
  /// This must contain room for
  /// <code>frame_size*channels</code>
  /// samples.
  /// @param frame_size <tt>int</tt>: The number of samples per channel of
  /// available space in \a pcm.
  /// If this is less than the maximum packet duration
  /// (120 ms; 5760 for 48kHz), this function will not be capable
  /// of decoding some packets. In the case of PLC (data==NULL)
  /// or FEC (decode_fec=1), then frame_size needs to be exactly
  /// the duration of audio that is missing, otherwise the
  /// decoder will not be in the optimal state to decode the
  /// next incoming packet. For the PLC and FEC cases, frame_size
  /// <b>must</b> be a multiple of 2.5 ms.
  /// @param decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band
  /// forward error correction data be decoded.
  /// If no such data is available, the frame is
  /// decoded as if it were lost.
  /// @returns Number of samples decoded on success or a negative error code
  /// (see @ref opus_errorcodes) on failure.
  int opus_projection_decode_float(
    ffi.Pointer<OpusProjectionDecoder> st,
    ffi.Pointer<ffi.Uint8> data,
    int len,
    ffi.Pointer<ffi.Float> pcm,
    int frame_size,
    int decode_fec,
  ) {
    return _opus_projection_decode_float(
      st,
      data,
      len,
      pcm,
      frame_size,
      decode_fec,
    );
  }

  late final _opus_projection_decode_float_ptr =
      _lookup<ffi.NativeFunction<_c_opus_projection_decode_float>>(
          'opus_projection_decode_float');
  late final _dart_opus_projection_decode_float _opus_projection_decode_float =
      _opus_projection_decode_float_ptr
          .asFunction<_dart_opus_projection_decode_float>();

  /// Perform a CTL function on a projection Opus decoder.
  ///
  /// Generally the request and subsequent arguments are generated by a
  /// convenience macro.
  /// @param st <tt>OpusProjectionDecoder*</tt>: Projection decoder state.
  /// @param request This and all remaining parameters should be replaced by one
  /// of the convenience macros in @ref opus_genericctls,
  /// @ref opus_decoderctls, @ref opus_multistream_ctls, or
  /// @ref opus_projection_ctls.
  /// @see opus_genericctls
  /// @see opus_decoderctls
  /// @see opus_multistream_ctls
  /// @see opus_projection_ctls
  int opus_projection_decoder_ctl(
    ffi.Pointer<OpusProjectionDecoder> st,
    int request,
  ) {
    return _opus_projection_decoder_ctl(
      st,
      request,
    );
  }

  late final _opus_projection_decoder_ctl_ptr =
      _lookup<ffi.NativeFunction<_c_opus_projection_decoder_ctl>>(
          'opus_projection_decoder_ctl');
  late final _dart_opus_projection_decoder_ctl _opus_projection_decoder_ctl =
      _opus_projection_decoder_ctl_ptr
          .asFunction<_dart_opus_projection_decoder_ctl>();

  /// Frees an <code>OpusProjectionDecoder</code> allocated by
  /// opus_projection_decoder_create().
  /// @param st <tt>OpusProjectionDecoder</tt>: Projection decoder state to be freed.
  void opus_projection_decoder_destroy(
    ffi.Pointer<OpusProjectionDecoder> st,
  ) {
    return _opus_projection_decoder_destroy(
      st,
    );
  }

  late final _opus_projection_decoder_destroy_ptr =
      _lookup<ffi.NativeFunction<_c_opus_projection_decoder_destroy>>(
          'opus_projection_decoder_destroy');
  late final _dart_opus_projection_decoder_destroy
      _opus_projection_decoder_destroy = _opus_projection_decoder_destroy_ptr
          .asFunction<_dart_opus_projection_decoder_destroy>();
}

class __fsid_t extends ffi.Struct {
  @ffi.Int32()
  external int _unique___val_item_0;
  @ffi.Int32()
  external int _unique___val_item_1;

  /// Helper for array `__val`.
  ArrayHelper___fsid_t___val_level0 get __val =>
      ArrayHelper___fsid_t___val_level0(this, [2], 0, 0);
}

/// Helper for array `__val` in struct `__fsid_t`.
class ArrayHelper___fsid_t___val_level0 {
  final __fsid_t _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper___fsid_t___val_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..$length exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique___val_item_0;
      case 1:
        return _struct._unique___val_item_1;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique___val_item_0 = value;
        break;
      case 1:
        _struct._unique___val_item_1 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class OpusCustomEncoder extends ffi.Opaque {}

class OpusCustomDecoder extends ffi.Opaque {}

class OpusCustomMode extends ffi.Opaque {}

class OpusEncoder extends ffi.Opaque {}

class OpusDecoder extends ffi.Opaque {}

class OpusRepacketizer extends ffi.Opaque {}

class OpusMSEncoder extends ffi.Opaque {}

class OpusMSDecoder extends ffi.Opaque {}

class OpusProjectionEncoder extends ffi.Opaque {}

class OpusProjectionDecoder extends ffi.Opaque {}

const int OPUS_OK = 0;

const int OPUS_BAD_ARG = -1;

const int OPUS_BUFFER_TOO_SMALL = -2;

const int OPUS_INTERNAL_ERROR = -3;

const int OPUS_INVALID_PACKET = -4;

const int OPUS_UNIMPLEMENTED = -5;

const int OPUS_INVALID_STATE = -6;

const int OPUS_ALLOC_FAIL = -7;

const int OPUS_SET_APPLICATION_REQUEST = 4000;

const int OPUS_GET_APPLICATION_REQUEST = 4001;

const int OPUS_SET_BITRATE_REQUEST = 4002;

const int OPUS_GET_BITRATE_REQUEST = 4003;

const int OPUS_SET_MAX_BANDWIDTH_REQUEST = 4004;

const int OPUS_GET_MAX_BANDWIDTH_REQUEST = 4005;

const int OPUS_SET_VBR_REQUEST = 4006;

const int OPUS_GET_VBR_REQUEST = 4007;

const int OPUS_SET_BANDWIDTH_REQUEST = 4008;

const int OPUS_GET_BANDWIDTH_REQUEST = 4009;

const int OPUS_SET_COMPLEXITY_REQUEST = 4010;

const int OPUS_GET_COMPLEXITY_REQUEST = 4011;

const int OPUS_SET_INBAND_FEC_REQUEST = 4012;

const int OPUS_GET_INBAND_FEC_REQUEST = 4013;

const int OPUS_SET_PACKET_LOSS_PERC_REQUEST = 4014;

const int OPUS_GET_PACKET_LOSS_PERC_REQUEST = 4015;

const int OPUS_SET_DTX_REQUEST = 4016;

const int OPUS_GET_DTX_REQUEST = 4017;

const int OPUS_SET_VBR_CONSTRAINT_REQUEST = 4020;

const int OPUS_GET_VBR_CONSTRAINT_REQUEST = 4021;

const int OPUS_SET_FORCE_CHANNELS_REQUEST = 4022;

const int OPUS_GET_FORCE_CHANNELS_REQUEST = 4023;

const int OPUS_SET_SIGNAL_REQUEST = 4024;

const int OPUS_GET_SIGNAL_REQUEST = 4025;

const int OPUS_GET_LOOKAHEAD_REQUEST = 4027;

const int OPUS_GET_SAMPLE_RATE_REQUEST = 4029;

const int OPUS_GET_FINAL_RANGE_REQUEST = 4031;

const int OPUS_GET_PITCH_REQUEST = 4033;

const int OPUS_SET_GAIN_REQUEST = 4034;

const int OPUS_GET_GAIN_REQUEST = 4045;

const int OPUS_SET_LSB_DEPTH_REQUEST = 4036;

const int OPUS_GET_LSB_DEPTH_REQUEST = 4037;

const int OPUS_GET_LAST_PACKET_DURATION_REQUEST = 4039;

const int OPUS_SET_EXPERT_FRAME_DURATION_REQUEST = 4040;

const int OPUS_GET_EXPERT_FRAME_DURATION_REQUEST = 4041;

const int OPUS_SET_PREDICTION_DISABLED_REQUEST = 4042;

const int OPUS_GET_PREDICTION_DISABLED_REQUEST = 4043;

const int OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST = 4046;

const int OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST = 4047;

const int OPUS_GET_IN_DTX_REQUEST = 4049;

const int OPUS_AUTO = -1000;

const int OPUS_BITRATE_MAX = -1;

const int OPUS_APPLICATION_VOIP = 2048;

const int OPUS_APPLICATION_AUDIO = 2049;

const int OPUS_APPLICATION_RESTRICTED_LOWDELAY = 2051;

const int OPUS_SIGNAL_VOICE = 3001;

const int OPUS_SIGNAL_MUSIC = 3002;

const int OPUS_BANDWIDTH_NARROWBAND = 1101;

const int OPUS_BANDWIDTH_MEDIUMBAND = 1102;

const int OPUS_BANDWIDTH_WIDEBAND = 1103;

const int OPUS_BANDWIDTH_SUPERWIDEBAND = 1104;

const int OPUS_BANDWIDTH_FULLBAND = 1105;

const int OPUS_FRAMESIZE_ARG = 5000;

const int OPUS_FRAMESIZE_2_5_MS = 5001;

const int OPUS_FRAMESIZE_5_MS = 5002;

const int OPUS_FRAMESIZE_10_MS = 5003;

const int OPUS_FRAMESIZE_20_MS = 5004;

const int OPUS_FRAMESIZE_40_MS = 5005;

const int OPUS_FRAMESIZE_60_MS = 5006;

const int OPUS_FRAMESIZE_80_MS = 5007;

const int OPUS_FRAMESIZE_100_MS = 5008;

const int OPUS_FRAMESIZE_120_MS = 5009;

const int OPUS_RESET_STATE = 4028;

const int OPUS_MULTISTREAM_GET_ENCODER_STATE_REQUEST = 5120;

const int OPUS_MULTISTREAM_GET_DECODER_STATE_REQUEST = 5122;

const int OPUS_PROJECTION_GET_DEMIXING_MATRIX_GAIN_REQUEST = 6001;

const int OPUS_PROJECTION_GET_DEMIXING_MATRIX_SIZE_REQUEST = 6003;

const int OPUS_PROJECTION_GET_DEMIXING_MATRIX_REQUEST = 6005;

typedef _c_opus_strerror = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 error,
);

typedef _dart_opus_strerror = ffi.Pointer<ffi.Int8> Function(
  int error,
);

typedef _c_opus_get_version_string = ffi.Pointer<ffi.Int8> Function();

typedef _dart_opus_get_version_string = ffi.Pointer<ffi.Int8> Function();

typedef _c_opus_custom_mode_create = ffi.Pointer<OpusCustomMode> Function(
  ffi.Int32 Fs,
  ffi.Int32 frame_size,
  ffi.Pointer<ffi.Int32> error,
);

typedef _dart_opus_custom_mode_create = ffi.Pointer<OpusCustomMode> Function(
  int Fs,
  int frame_size,
  ffi.Pointer<ffi.Int32> error,
);

typedef _c_opus_custom_mode_destroy = ffi.Void Function(
  ffi.Pointer<OpusCustomMode> mode,
);

typedef _dart_opus_custom_mode_destroy = void Function(
  ffi.Pointer<OpusCustomMode> mode,
);

typedef _c_opus_custom_encoder_get_size = ffi.Int32 Function(
  ffi.Pointer<OpusCustomMode> mode,
  ffi.Int32 channels,
);

typedef _dart_opus_custom_encoder_get_size = int Function(
  ffi.Pointer<OpusCustomMode> mode,
  int channels,
);

typedef _c_opus_custom_encoder_create = ffi.Pointer<OpusCustomEncoder> Function(
  ffi.Pointer<OpusCustomMode> mode,
  ffi.Int32 channels,
  ffi.Pointer<ffi.Int32> error,
);

typedef _dart_opus_custom_encoder_create = ffi.Pointer<OpusCustomEncoder>
    Function(
  ffi.Pointer<OpusCustomMode> mode,
  int channels,
  ffi.Pointer<ffi.Int32> error,
);

typedef _c_opus_custom_encoder_destroy = ffi.Void Function(
  ffi.Pointer<OpusCustomEncoder> st,
);

typedef _dart_opus_custom_encoder_destroy = void Function(
  ffi.Pointer<OpusCustomEncoder> st,
);

typedef _c_opus_custom_encode_float = ffi.Int32 Function(
  ffi.Pointer<OpusCustomEncoder> st,
  ffi.Pointer<ffi.Float> pcm,
  ffi.Int32 frame_size,
  ffi.Pointer<ffi.Uint8> compressed,
  ffi.Int32 maxCompressedBytes,
);

typedef _dart_opus_custom_encode_float = int Function(
  ffi.Pointer<OpusCustomEncoder> st,
  ffi.Pointer<ffi.Float> pcm,
  int frame_size,
  ffi.Pointer<ffi.Uint8> compressed,
  int maxCompressedBytes,
);

typedef _c_opus_custom_encode = ffi.Int32 Function(
  ffi.Pointer<OpusCustomEncoder> st,
  ffi.Pointer<ffi.Int16> pcm,
  ffi.Int32 frame_size,
  ffi.Pointer<ffi.Uint8> compressed,
  ffi.Int32 maxCompressedBytes,
);

typedef _dart_opus_custom_encode = int Function(
  ffi.Pointer<OpusCustomEncoder> st,
  ffi.Pointer<ffi.Int16> pcm,
  int frame_size,
  ffi.Pointer<ffi.Uint8> compressed,
  int maxCompressedBytes,
);

typedef _c_opus_custom_encoder_ctl = ffi.Int32 Function(
  ffi.Pointer<OpusCustomEncoder> st,
  ffi.Int32 request,
);

typedef _dart_opus_custom_encoder_ctl = int Function(
  ffi.Pointer<OpusCustomEncoder> st,
  int request,
);

typedef _c_opus_custom_decoder_get_size = ffi.Int32 Function(
  ffi.Pointer<OpusCustomMode> mode,
  ffi.Int32 channels,
);

typedef _dart_opus_custom_decoder_get_size = int Function(
  ffi.Pointer<OpusCustomMode> mode,
  int channels,
);

typedef _c_opus_custom_decoder_init = ffi.Int32 Function(
  ffi.Pointer<OpusCustomDecoder> st,
  ffi.Pointer<OpusCustomMode> mode,
  ffi.Int32 channels,
);

typedef _dart_opus_custom_decoder_init = int Function(
  ffi.Pointer<OpusCustomDecoder> st,
  ffi.Pointer<OpusCustomMode> mode,
  int channels,
);

typedef _c_opus_custom_decoder_create = ffi.Pointer<OpusCustomDecoder> Function(
  ffi.Pointer<OpusCustomMode> mode,
  ffi.Int32 channels,
  ffi.Pointer<ffi.Int32> error,
);

typedef _dart_opus_custom_decoder_create = ffi.Pointer<OpusCustomDecoder>
    Function(
  ffi.Pointer<OpusCustomMode> mode,
  int channels,
  ffi.Pointer<ffi.Int32> error,
);

typedef _c_opus_custom_decoder_destroy = ffi.Void Function(
  ffi.Pointer<OpusCustomDecoder> st,
);

typedef _dart_opus_custom_decoder_destroy = void Function(
  ffi.Pointer<OpusCustomDecoder> st,
);

typedef _c_opus_custom_decode_float = ffi.Int32 Function(
  ffi.Pointer<OpusCustomDecoder> st,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 len,
  ffi.Pointer<ffi.Float> pcm,
  ffi.Int32 frame_size,
);

typedef _dart_opus_custom_decode_float = int Function(
  ffi.Pointer<OpusCustomDecoder> st,
  ffi.Pointer<ffi.Uint8> data,
  int len,
  ffi.Pointer<ffi.Float> pcm,
  int frame_size,
);

typedef _c_opus_custom_decode = ffi.Int32 Function(
  ffi.Pointer<OpusCustomDecoder> st,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 len,
  ffi.Pointer<ffi.Int16> pcm,
  ffi.Int32 frame_size,
);

typedef _dart_opus_custom_decode = int Function(
  ffi.Pointer<OpusCustomDecoder> st,
  ffi.Pointer<ffi.Uint8> data,
  int len,
  ffi.Pointer<ffi.Int16> pcm,
  int frame_size,
);

typedef _c_opus_custom_decoder_ctl = ffi.Int32 Function(
  ffi.Pointer<OpusCustomDecoder> st,
  ffi.Int32 request,
);

typedef _dart_opus_custom_decoder_ctl = int Function(
  ffi.Pointer<OpusCustomDecoder> st,
  int request,
);

typedef _c_opus_encoder_get_size = ffi.Int32 Function(
  ffi.Int32 channels,
);

typedef _dart_opus_encoder_get_size = int Function(
  int channels,
);

typedef _c_opus_encoder_create = ffi.Pointer<OpusEncoder> Function(
  ffi.Int32 Fs,
  ffi.Int32 channels,
  ffi.Int32 application,
  ffi.Pointer<ffi.Int32> error,
);

typedef _dart_opus_encoder_create = ffi.Pointer<OpusEncoder> Function(
  int Fs,
  int channels,
  int application,
  ffi.Pointer<ffi.Int32> error,
);

typedef _c_opus_encoder_init = ffi.Int32 Function(
  ffi.Pointer<OpusEncoder> st,
  ffi.Int32 Fs,
  ffi.Int32 channels,
  ffi.Int32 application,
);

typedef _dart_opus_encoder_init = int Function(
  ffi.Pointer<OpusEncoder> st,
  int Fs,
  int channels,
  int application,
);

typedef _c_opus_encode = ffi.Int32 Function(
  ffi.Pointer<OpusEncoder> st,
  ffi.Pointer<ffi.Int16> pcm,
  ffi.Int32 frame_size,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 max_data_bytes,
);

typedef _dart_opus_encode = int Function(
  ffi.Pointer<OpusEncoder> st,
  ffi.Pointer<ffi.Int16> pcm,
  int frame_size,
  ffi.Pointer<ffi.Uint8> data,
  int max_data_bytes,
);

typedef _c_opus_encode_float = ffi.Int32 Function(
  ffi.Pointer<OpusEncoder> st,
  ffi.Pointer<ffi.Float> pcm,
  ffi.Int32 frame_size,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 max_data_bytes,
);

typedef _dart_opus_encode_float = int Function(
  ffi.Pointer<OpusEncoder> st,
  ffi.Pointer<ffi.Float> pcm,
  int frame_size,
  ffi.Pointer<ffi.Uint8> data,
  int max_data_bytes,
);

typedef _c_opus_encoder_destroy = ffi.Void Function(
  ffi.Pointer<OpusEncoder> st,
);

typedef _dart_opus_encoder_destroy = void Function(
  ffi.Pointer<OpusEncoder> st,
);

typedef _c_opus_encoder_ctl = ffi.Int32 Function(
  ffi.Pointer<OpusEncoder> st,
  ffi.Int32 request,
);

typedef _dart_opus_encoder_ctl = int Function(
  ffi.Pointer<OpusEncoder> st,
  int request,
);

typedef _c_opus_decoder_get_size = ffi.Int32 Function(
  ffi.Int32 channels,
);

typedef _dart_opus_decoder_get_size = int Function(
  int channels,
);

typedef _c_opus_decoder_create = ffi.Pointer<OpusDecoder> Function(
  ffi.Int32 Fs,
  ffi.Int32 channels,
  ffi.Pointer<ffi.Int32> error,
);

typedef _dart_opus_decoder_create = ffi.Pointer<OpusDecoder> Function(
  int Fs,
  int channels,
  ffi.Pointer<ffi.Int32> error,
);

typedef _c_opus_decoder_init = ffi.Int32 Function(
  ffi.Pointer<OpusDecoder> st,
  ffi.Int32 Fs,
  ffi.Int32 channels,
);

typedef _dart_opus_decoder_init = int Function(
  ffi.Pointer<OpusDecoder> st,
  int Fs,
  int channels,
);

typedef _c_opus_decode = ffi.Int32 Function(
  ffi.Pointer<OpusDecoder> st,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 len,
  ffi.Pointer<ffi.Int16> pcm,
  ffi.Int32 frame_size,
  ffi.Int32 decode_fec,
);

typedef _dart_opus_decode = int Function(
  ffi.Pointer<OpusDecoder> st,
  ffi.Pointer<ffi.Uint8> data,
  int len,
  ffi.Pointer<ffi.Int16> pcm,
  int frame_size,
  int decode_fec,
);

typedef _c_opus_decode_float = ffi.Int32 Function(
  ffi.Pointer<OpusDecoder> st,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 len,
  ffi.Pointer<ffi.Float> pcm,
  ffi.Int32 frame_size,
  ffi.Int32 decode_fec,
);

typedef _dart_opus_decode_float = int Function(
  ffi.Pointer<OpusDecoder> st,
  ffi.Pointer<ffi.Uint8> data,
  int len,
  ffi.Pointer<ffi.Float> pcm,
  int frame_size,
  int decode_fec,
);

typedef _c_opus_decoder_ctl = ffi.Int32 Function(
  ffi.Pointer<OpusDecoder> st,
  ffi.Int32 request,
);

typedef _dart_opus_decoder_ctl = int Function(
  ffi.Pointer<OpusDecoder> st,
  int request,
);

typedef _c_opus_decoder_destroy = ffi.Void Function(
  ffi.Pointer<OpusDecoder> st,
);

typedef _dart_opus_decoder_destroy = void Function(
  ffi.Pointer<OpusDecoder> st,
);

typedef _c_opus_packet_parse = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 len,
  ffi.Pointer<ffi.Uint8> out_toc,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> frames,
  ffi.Pointer<ffi.Int16> size,
  ffi.Pointer<ffi.Int32> payload_offset,
);

typedef _dart_opus_packet_parse = int Function(
  ffi.Pointer<ffi.Uint8> data,
  int len,
  ffi.Pointer<ffi.Uint8> out_toc,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> frames,
  ffi.Pointer<ffi.Int16> size,
  ffi.Pointer<ffi.Int32> payload_offset,
);

typedef _c_opus_packet_get_bandwidth = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> data,
);

typedef _dart_opus_packet_get_bandwidth = int Function(
  ffi.Pointer<ffi.Uint8> data,
);

typedef _c_opus_packet_get_samples_per_frame = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 Fs,
);

typedef _dart_opus_packet_get_samples_per_frame = int Function(
  ffi.Pointer<ffi.Uint8> data,
  int Fs,
);

typedef _c_opus_packet_get_nb_channels = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> data,
);

typedef _dart_opus_packet_get_nb_channels = int Function(
  ffi.Pointer<ffi.Uint8> data,
);

typedef _c_opus_packet_get_nb_frames = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> packet,
  ffi.Int32 len,
);

typedef _dart_opus_packet_get_nb_frames = int Function(
  ffi.Pointer<ffi.Uint8> packet,
  int len,
);

typedef _c_opus_packet_get_nb_samples = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> packet,
  ffi.Int32 len,
  ffi.Int32 Fs,
);

typedef _dart_opus_packet_get_nb_samples = int Function(
  ffi.Pointer<ffi.Uint8> packet,
  int len,
  int Fs,
);

typedef _c_opus_decoder_get_nb_samples = ffi.Int32 Function(
  ffi.Pointer<OpusDecoder> dec,
  ffi.Pointer<ffi.Uint8> packet,
  ffi.Int32 len,
);

typedef _dart_opus_decoder_get_nb_samples = int Function(
  ffi.Pointer<OpusDecoder> dec,
  ffi.Pointer<ffi.Uint8> packet,
  int len,
);

typedef _c_opus_pcm_soft_clip = ffi.Void Function(
  ffi.Pointer<ffi.Float> pcm,
  ffi.Int32 frame_size,
  ffi.Int32 channels,
  ffi.Pointer<ffi.Float> softclip_mem,
);

typedef _dart_opus_pcm_soft_clip = void Function(
  ffi.Pointer<ffi.Float> pcm,
  int frame_size,
  int channels,
  ffi.Pointer<ffi.Float> softclip_mem,
);

typedef _c_opus_repacketizer_get_size = ffi.Int32 Function();

typedef _dart_opus_repacketizer_get_size = int Function();

typedef _c_opus_repacketizer_init = ffi.Pointer<OpusRepacketizer> Function(
  ffi.Pointer<OpusRepacketizer> rp,
);

typedef _dart_opus_repacketizer_init = ffi.Pointer<OpusRepacketizer> Function(
  ffi.Pointer<OpusRepacketizer> rp,
);

typedef _c_opus_repacketizer_create = ffi.Pointer<OpusRepacketizer> Function();

typedef _dart_opus_repacketizer_create = ffi.Pointer<OpusRepacketizer>
    Function();

typedef _c_opus_repacketizer_destroy = ffi.Void Function(
  ffi.Pointer<OpusRepacketizer> rp,
);

typedef _dart_opus_repacketizer_destroy = void Function(
  ffi.Pointer<OpusRepacketizer> rp,
);

typedef _c_opus_repacketizer_cat = ffi.Int32 Function(
  ffi.Pointer<OpusRepacketizer> rp,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 len,
);

typedef _dart_opus_repacketizer_cat = int Function(
  ffi.Pointer<OpusRepacketizer> rp,
  ffi.Pointer<ffi.Uint8> data,
  int len,
);

typedef _c_opus_repacketizer_out_range = ffi.Int32 Function(
  ffi.Pointer<OpusRepacketizer> rp,
  ffi.Int32 begin,
  ffi.Int32 end,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 maxlen,
);

typedef _dart_opus_repacketizer_out_range = int Function(
  ffi.Pointer<OpusRepacketizer> rp,
  int begin,
  int end,
  ffi.Pointer<ffi.Uint8> data,
  int maxlen,
);

typedef _c_opus_repacketizer_get_nb_frames = ffi.Int32 Function(
  ffi.Pointer<OpusRepacketizer> rp,
);

typedef _dart_opus_repacketizer_get_nb_frames = int Function(
  ffi.Pointer<OpusRepacketizer> rp,
);

typedef _c_opus_repacketizer_out = ffi.Int32 Function(
  ffi.Pointer<OpusRepacketizer> rp,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 maxlen,
);

typedef _dart_opus_repacketizer_out = int Function(
  ffi.Pointer<OpusRepacketizer> rp,
  ffi.Pointer<ffi.Uint8> data,
  int maxlen,
);

typedef _c_opus_packet_pad = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 len,
  ffi.Int32 new_len,
);

typedef _dart_opus_packet_pad = int Function(
  ffi.Pointer<ffi.Uint8> data,
  int len,
  int new_len,
);

typedef _c_opus_packet_unpad = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 len,
);

typedef _dart_opus_packet_unpad = int Function(
  ffi.Pointer<ffi.Uint8> data,
  int len,
);

typedef _c_opus_multistream_packet_pad = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 len,
  ffi.Int32 new_len,
  ffi.Int32 nb_streams,
);

typedef _dart_opus_multistream_packet_pad = int Function(
  ffi.Pointer<ffi.Uint8> data,
  int len,
  int new_len,
  int nb_streams,
);

typedef _c_opus_multistream_packet_unpad = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 len,
  ffi.Int32 nb_streams,
);

typedef _dart_opus_multistream_packet_unpad = int Function(
  ffi.Pointer<ffi.Uint8> data,
  int len,
  int nb_streams,
);

typedef _c_opus_multistream_encoder_get_size = ffi.Int32 Function(
  ffi.Int32 streams,
  ffi.Int32 coupled_streams,
);

typedef _dart_opus_multistream_encoder_get_size = int Function(
  int streams,
  int coupled_streams,
);

typedef _c_opus_multistream_surround_encoder_get_size = ffi.Int32 Function(
  ffi.Int32 channels,
  ffi.Int32 mapping_family,
);

typedef _dart_opus_multistream_surround_encoder_get_size = int Function(
  int channels,
  int mapping_family,
);

typedef _c_opus_multistream_encoder_create = ffi.Pointer<OpusMSEncoder>
    Function(
  ffi.Int32 Fs,
  ffi.Int32 channels,
  ffi.Int32 streams,
  ffi.Int32 coupled_streams,
  ffi.Pointer<ffi.Uint8> mapping,
  ffi.Int32 application,
  ffi.Pointer<ffi.Int32> error,
);

typedef _dart_opus_multistream_encoder_create = ffi.Pointer<OpusMSEncoder>
    Function(
  int Fs,
  int channels,
  int streams,
  int coupled_streams,
  ffi.Pointer<ffi.Uint8> mapping,
  int application,
  ffi.Pointer<ffi.Int32> error,
);

typedef _c_opus_multistream_surround_encoder_create = ffi.Pointer<OpusMSEncoder>
    Function(
  ffi.Int32 Fs,
  ffi.Int32 channels,
  ffi.Int32 mapping_family,
  ffi.Pointer<ffi.Int32> streams,
  ffi.Pointer<ffi.Int32> coupled_streams,
  ffi.Pointer<ffi.Uint8> mapping,
  ffi.Int32 application,
  ffi.Pointer<ffi.Int32> error,
);

typedef _dart_opus_multistream_surround_encoder_create
    = ffi.Pointer<OpusMSEncoder> Function(
  int Fs,
  int channels,
  int mapping_family,
  ffi.Pointer<ffi.Int32> streams,
  ffi.Pointer<ffi.Int32> coupled_streams,
  ffi.Pointer<ffi.Uint8> mapping,
  int application,
  ffi.Pointer<ffi.Int32> error,
);

typedef _c_opus_multistream_encoder_init = ffi.Int32 Function(
  ffi.Pointer<OpusMSEncoder> st,
  ffi.Int32 Fs,
  ffi.Int32 channels,
  ffi.Int32 streams,
  ffi.Int32 coupled_streams,
  ffi.Pointer<ffi.Uint8> mapping,
  ffi.Int32 application,
);

typedef _dart_opus_multistream_encoder_init = int Function(
  ffi.Pointer<OpusMSEncoder> st,
  int Fs,
  int channels,
  int streams,
  int coupled_streams,
  ffi.Pointer<ffi.Uint8> mapping,
  int application,
);

typedef _c_opus_multistream_surround_encoder_init = ffi.Int32 Function(
  ffi.Pointer<OpusMSEncoder> st,
  ffi.Int32 Fs,
  ffi.Int32 channels,
  ffi.Int32 mapping_family,
  ffi.Pointer<ffi.Int32> streams,
  ffi.Pointer<ffi.Int32> coupled_streams,
  ffi.Pointer<ffi.Uint8> mapping,
  ffi.Int32 application,
);

typedef _dart_opus_multistream_surround_encoder_init = int Function(
  ffi.Pointer<OpusMSEncoder> st,
  int Fs,
  int channels,
  int mapping_family,
  ffi.Pointer<ffi.Int32> streams,
  ffi.Pointer<ffi.Int32> coupled_streams,
  ffi.Pointer<ffi.Uint8> mapping,
  int application,
);

typedef _c_opus_multistream_encode = ffi.Int32 Function(
  ffi.Pointer<OpusMSEncoder> st,
  ffi.Pointer<ffi.Int16> pcm,
  ffi.Int32 frame_size,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 max_data_bytes,
);

typedef _dart_opus_multistream_encode = int Function(
  ffi.Pointer<OpusMSEncoder> st,
  ffi.Pointer<ffi.Int16> pcm,
  int frame_size,
  ffi.Pointer<ffi.Uint8> data,
  int max_data_bytes,
);

typedef _c_opus_multistream_encode_float = ffi.Int32 Function(
  ffi.Pointer<OpusMSEncoder> st,
  ffi.Pointer<ffi.Float> pcm,
  ffi.Int32 frame_size,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 max_data_bytes,
);

typedef _dart_opus_multistream_encode_float = int Function(
  ffi.Pointer<OpusMSEncoder> st,
  ffi.Pointer<ffi.Float> pcm,
  int frame_size,
  ffi.Pointer<ffi.Uint8> data,
  int max_data_bytes,
);

typedef _c_opus_multistream_encoder_destroy = ffi.Void Function(
  ffi.Pointer<OpusMSEncoder> st,
);

typedef _dart_opus_multistream_encoder_destroy = void Function(
  ffi.Pointer<OpusMSEncoder> st,
);

typedef _c_opus_multistream_encoder_ctl = ffi.Int32 Function(
  ffi.Pointer<OpusMSEncoder> st,
  ffi.Int32 request,
);

typedef _dart_opus_multistream_encoder_ctl = int Function(
  ffi.Pointer<OpusMSEncoder> st,
  int request,
);

typedef _c_opus_multistream_decoder_get_size = ffi.Int32 Function(
  ffi.Int32 streams,
  ffi.Int32 coupled_streams,
);

typedef _dart_opus_multistream_decoder_get_size = int Function(
  int streams,
  int coupled_streams,
);

typedef _c_opus_multistream_decoder_create = ffi.Pointer<OpusMSDecoder>
    Function(
  ffi.Int32 Fs,
  ffi.Int32 channels,
  ffi.Int32 streams,
  ffi.Int32 coupled_streams,
  ffi.Pointer<ffi.Uint8> mapping,
  ffi.Pointer<ffi.Int32> error,
);

typedef _dart_opus_multistream_decoder_create = ffi.Pointer<OpusMSDecoder>
    Function(
  int Fs,
  int channels,
  int streams,
  int coupled_streams,
  ffi.Pointer<ffi.Uint8> mapping,
  ffi.Pointer<ffi.Int32> error,
);

typedef _c_opus_multistream_decoder_init = ffi.Int32 Function(
  ffi.Pointer<OpusMSDecoder> st,
  ffi.Int32 Fs,
  ffi.Int32 channels,
  ffi.Int32 streams,
  ffi.Int32 coupled_streams,
  ffi.Pointer<ffi.Uint8> mapping,
);

typedef _dart_opus_multistream_decoder_init = int Function(
  ffi.Pointer<OpusMSDecoder> st,
  int Fs,
  int channels,
  int streams,
  int coupled_streams,
  ffi.Pointer<ffi.Uint8> mapping,
);

typedef _c_opus_multistream_decode = ffi.Int32 Function(
  ffi.Pointer<OpusMSDecoder> st,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 len,
  ffi.Pointer<ffi.Int16> pcm,
  ffi.Int32 frame_size,
  ffi.Int32 decode_fec,
);

typedef _dart_opus_multistream_decode = int Function(
  ffi.Pointer<OpusMSDecoder> st,
  ffi.Pointer<ffi.Uint8> data,
  int len,
  ffi.Pointer<ffi.Int16> pcm,
  int frame_size,
  int decode_fec,
);

typedef _c_opus_multistream_decode_float = ffi.Int32 Function(
  ffi.Pointer<OpusMSDecoder> st,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 len,
  ffi.Pointer<ffi.Float> pcm,
  ffi.Int32 frame_size,
  ffi.Int32 decode_fec,
);

typedef _dart_opus_multistream_decode_float = int Function(
  ffi.Pointer<OpusMSDecoder> st,
  ffi.Pointer<ffi.Uint8> data,
  int len,
  ffi.Pointer<ffi.Float> pcm,
  int frame_size,
  int decode_fec,
);

typedef _c_opus_multistream_decoder_ctl = ffi.Int32 Function(
  ffi.Pointer<OpusMSDecoder> st,
  ffi.Int32 request,
);

typedef _dart_opus_multistream_decoder_ctl = int Function(
  ffi.Pointer<OpusMSDecoder> st,
  int request,
);

typedef _c_opus_multistream_decoder_destroy = ffi.Void Function(
  ffi.Pointer<OpusMSDecoder> st,
);

typedef _dart_opus_multistream_decoder_destroy = void Function(
  ffi.Pointer<OpusMSDecoder> st,
);

typedef _c_opus_projection_ambisonics_encoder_get_size = ffi.Int32 Function(
  ffi.Int32 channels,
  ffi.Int32 mapping_family,
);

typedef _dart_opus_projection_ambisonics_encoder_get_size = int Function(
  int channels,
  int mapping_family,
);

typedef _c_opus_projection_ambisonics_encoder_create
    = ffi.Pointer<OpusProjectionEncoder> Function(
  ffi.Int32 Fs,
  ffi.Int32 channels,
  ffi.Int32 mapping_family,
  ffi.Pointer<ffi.Int32> streams,
  ffi.Pointer<ffi.Int32> coupled_streams,
  ffi.Int32 application,
  ffi.Pointer<ffi.Int32> error,
);

typedef _dart_opus_projection_ambisonics_encoder_create
    = ffi.Pointer<OpusProjectionEncoder> Function(
  int Fs,
  int channels,
  int mapping_family,
  ffi.Pointer<ffi.Int32> streams,
  ffi.Pointer<ffi.Int32> coupled_streams,
  int application,
  ffi.Pointer<ffi.Int32> error,
);

typedef _c_opus_projection_ambisonics_encoder_init = ffi.Int32 Function(
  ffi.Pointer<OpusProjectionEncoder> st,
  ffi.Int32 Fs,
  ffi.Int32 channels,
  ffi.Int32 mapping_family,
  ffi.Pointer<ffi.Int32> streams,
  ffi.Pointer<ffi.Int32> coupled_streams,
  ffi.Int32 application,
);

typedef _dart_opus_projection_ambisonics_encoder_init = int Function(
  ffi.Pointer<OpusProjectionEncoder> st,
  int Fs,
  int channels,
  int mapping_family,
  ffi.Pointer<ffi.Int32> streams,
  ffi.Pointer<ffi.Int32> coupled_streams,
  int application,
);

typedef _c_opus_projection_encode = ffi.Int32 Function(
  ffi.Pointer<OpusProjectionEncoder> st,
  ffi.Pointer<ffi.Int16> pcm,
  ffi.Int32 frame_size,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 max_data_bytes,
);

typedef _dart_opus_projection_encode = int Function(
  ffi.Pointer<OpusProjectionEncoder> st,
  ffi.Pointer<ffi.Int16> pcm,
  int frame_size,
  ffi.Pointer<ffi.Uint8> data,
  int max_data_bytes,
);

typedef _c_opus_projection_encode_float = ffi.Int32 Function(
  ffi.Pointer<OpusProjectionEncoder> st,
  ffi.Pointer<ffi.Float> pcm,
  ffi.Int32 frame_size,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 max_data_bytes,
);

typedef _dart_opus_projection_encode_float = int Function(
  ffi.Pointer<OpusProjectionEncoder> st,
  ffi.Pointer<ffi.Float> pcm,
  int frame_size,
  ffi.Pointer<ffi.Uint8> data,
  int max_data_bytes,
);

typedef _c_opus_projection_encoder_destroy = ffi.Void Function(
  ffi.Pointer<OpusProjectionEncoder> st,
);

typedef _dart_opus_projection_encoder_destroy = void Function(
  ffi.Pointer<OpusProjectionEncoder> st,
);

typedef _c_opus_projection_encoder_ctl = ffi.Int32 Function(
  ffi.Pointer<OpusProjectionEncoder> st,
  ffi.Int32 request,
);

typedef _dart_opus_projection_encoder_ctl = int Function(
  ffi.Pointer<OpusProjectionEncoder> st,
  int request,
);

typedef _c_opus_projection_decoder_get_size = ffi.Int32 Function(
  ffi.Int32 channels,
  ffi.Int32 streams,
  ffi.Int32 coupled_streams,
);

typedef _dart_opus_projection_decoder_get_size = int Function(
  int channels,
  int streams,
  int coupled_streams,
);

typedef _c_opus_projection_decoder_create = ffi.Pointer<OpusProjectionDecoder>
    Function(
  ffi.Int32 Fs,
  ffi.Int32 channels,
  ffi.Int32 streams,
  ffi.Int32 coupled_streams,
  ffi.Pointer<ffi.Uint8> demixing_matrix,
  ffi.Int32 demixing_matrix_size,
  ffi.Pointer<ffi.Int32> error,
);

typedef _dart_opus_projection_decoder_create
    = ffi.Pointer<OpusProjectionDecoder> Function(
  int Fs,
  int channels,
  int streams,
  int coupled_streams,
  ffi.Pointer<ffi.Uint8> demixing_matrix,
  int demixing_matrix_size,
  ffi.Pointer<ffi.Int32> error,
);

typedef _c_opus_projection_decoder_init = ffi.Int32 Function(
  ffi.Pointer<OpusProjectionDecoder> st,
  ffi.Int32 Fs,
  ffi.Int32 channels,
  ffi.Int32 streams,
  ffi.Int32 coupled_streams,
  ffi.Pointer<ffi.Uint8> demixing_matrix,
  ffi.Int32 demixing_matrix_size,
);

typedef _dart_opus_projection_decoder_init = int Function(
  ffi.Pointer<OpusProjectionDecoder> st,
  int Fs,
  int channels,
  int streams,
  int coupled_streams,
  ffi.Pointer<ffi.Uint8> demixing_matrix,
  int demixing_matrix_size,
);

typedef _c_opus_projection_decode = ffi.Int32 Function(
  ffi.Pointer<OpusProjectionDecoder> st,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 len,
  ffi.Pointer<ffi.Int16> pcm,
  ffi.Int32 frame_size,
  ffi.Int32 decode_fec,
);

typedef _dart_opus_projection_decode = int Function(
  ffi.Pointer<OpusProjectionDecoder> st,
  ffi.Pointer<ffi.Uint8> data,
  int len,
  ffi.Pointer<ffi.Int16> pcm,
  int frame_size,
  int decode_fec,
);

typedef _c_opus_projection_decode_float = ffi.Int32 Function(
  ffi.Pointer<OpusProjectionDecoder> st,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 len,
  ffi.Pointer<ffi.Float> pcm,
  ffi.Int32 frame_size,
  ffi.Int32 decode_fec,
);

typedef _dart_opus_projection_decode_float = int Function(
  ffi.Pointer<OpusProjectionDecoder> st,
  ffi.Pointer<ffi.Uint8> data,
  int len,
  ffi.Pointer<ffi.Float> pcm,
  int frame_size,
  int decode_fec,
);

typedef _c_opus_projection_decoder_ctl = ffi.Int32 Function(
  ffi.Pointer<OpusProjectionDecoder> st,
  ffi.Int32 request,
);

typedef _dart_opus_projection_decoder_ctl = int Function(
  ffi.Pointer<OpusProjectionDecoder> st,
  int request,
);

typedef _c_opus_projection_decoder_destroy = ffi.Void Function(
  ffi.Pointer<OpusProjectionDecoder> st,
);

typedef _dart_opus_projection_decoder_destroy = void Function(
  ffi.Pointer<OpusProjectionDecoder> st,
);
